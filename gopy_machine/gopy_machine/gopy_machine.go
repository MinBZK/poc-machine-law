/*
cgo stubs for package gopy_machine.
File is generated by gopy. Do not edit.
gopy build -vm=python3 -output=gopy_machine/tmp -name=gopy_machine github.com/minbzk/poc-machine-law/machinev2/service
*/

package main

/*

#cgo CFLAGS: "-I/home/chiel/.local/share/uv/python/cpython-3.13.0-linux-x86_64-gnu/include/python3.13" -Wno-error -Wno-implicit-function-declaration -Wno-int-conversion
#cgo LDFLAGS: "-L/nix/store/6llg9sms6xw69whqpdkgldjz61dlk9c2-python3-3.13.1/lib" "-lpython3.13" -ldl -L/nix/store/sbc37bmgpzr7wvlbm9lgf4y6q6dyz40q-libxcrypt-4.4.36/lib -lm

// #define Py_LIMITED_API // need full API for PyRun*
#include <Python.h>
typedef uint8_t bool;
// static inline is trick for avoiding need for extra .c file
// the following are used for build value -- switch on reflect.Kind
// or the types equivalent
static inline PyObject* gopy_build_bool(uint8_t val) {
	return Py_BuildValue("b", val);
}
static inline PyObject* gopy_build_int64(int64_t val) {
	return Py_BuildValue("k", val);
}
static inline PyObject* gopy_build_uint64(uint64_t val) {
	return Py_BuildValue("K", val);
}
static inline PyObject* gopy_build_float64(double val) {
	return Py_BuildValue("d", val);
}
static inline PyObject* gopy_build_string(const char* val) {
	return Py_BuildValue("s", val);
}
static inline void gopy_decref(PyObject* obj) { // macro
	Py_XDECREF(obj);
}
static inline void gopy_incref(PyObject* obj) { // macro
	Py_XINCREF(obj);
}
static inline int gopy_method_check(PyObject* obj) { // macro
	return PyMethod_Check(obj);
}
static inline void gopy_err_handle() {
	if(PyErr_Occurred() != NULL) {
		PyErr_Print();
	}
}

*/
import "C"
import (
	"errors"
	"reflect"
	"unsafe"

	"github.com/go-python/gopy/gopyh" // handler

	"context"
	"database/sql/driver"
	"time"

	"github.com/google/uuid"
	"github.com/minbzk/poc-machine-law/machinev2/casemanager"
	s1_context "github.com/minbzk/poc-machine-law/machinev2/context"
	"github.com/minbzk/poc-machine-law/machinev2/logging"
	"github.com/minbzk/poc-machine-law/machinev2/model"
	"github.com/minbzk/poc-machine-law/machinev2/service"
	"github.com/minbzk/poc-machine-law/machinev2/utils"
)

// main doesn't do anything in lib / pkg mode, but is essential for exe mode
func main() {

}

// initialization functions -- can be called from python after library is loaded
// GoPyInitRunFile runs a separate python file -- call in GoPyInit if it
// steals the main thread e.g., for GUI event loop, as in GoGi startup.

//export GoPyInit
func GoPyInit() {

}

// type for the handle -- int64 for speed (can switch to string)
type GoHandle int64
type CGoHandle C.longlong

// DecRef decrements the reference count for the specified handle
// and deletes it it goes to zero.
//
//export DecRef
func DecRef(handle CGoHandle) {
	gopyh.DecRef(gopyh.CGoHandle(handle))
}

// IncRef increments the reference count for the specified handle.
//
//export IncRef
func IncRef(handle CGoHandle) {
	gopyh.IncRef(gopyh.CGoHandle(handle))
}

// NumHandles returns the number of handles currently in use.
//
//export NumHandles
func NumHandles() int {
	return gopyh.NumHandles()
}

// boolGoToPy converts a Go bool to python-compatible C.char
func boolGoToPy(b bool) C.char {
	if b {
		return 1
	}
	return 0
}

// boolPyToGo converts a python-compatible C.Char to Go bool
func boolPyToGo(b C.char) bool {
	if b != 0 {
		return true
	}
	return false
}

func complex64GoToPy(c complex64) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex64PyToGo(o *C.PyObject) complex64 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float32(v.real), float32(v.imag))
}

func complex128GoToPy(c complex128) *C.PyObject {
	return C.PyComplex_FromDoubles(C.double(real(c)), C.double(imag(c)))
}

func complex128PyToGo(o *C.PyObject) complex128 {
	v := C.PyComplex_AsCComplex(o)
	return complex(float64(v.real), float64(v.imag))
}

// errorGoToPy converts a Go error to python-compatible C.CString
func errorGoToPy(e error) *C.char {
	if e != nil {
		return C.CString(e.Error())
	}
	return C.CString("")
}

// --- generated code for package: gopy_machine below: ---

// ---- External Types Outside of Targeted Packages ---

// Converters for pointer handles for type: *casemanager.Case
func ptrFromHandle_Ptr_casemanager_Case(h CGoHandle) *casemanager.Case {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*casemanager.Case")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(casemanager.Case{})).(*casemanager.Case)
}
func handleFromPtr_Ptr_casemanager_Case(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*casemanager.Case", p))
}

// Converters for pointer handles for type: *model.Claim
func ptrFromHandle_Ptr_model_Claim(h CGoHandle) *model.Claim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*model.Claim")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.Claim{})).(*model.Claim)
}
func handleFromPtr_Ptr_model_Claim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*model.Claim", p))
}

// Converters for pointer handles for type: *model.Event
func ptrFromHandle_Ptr_model_Event(h CGoHandle) *model.Event {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*model.Event")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.Event{})).(*model.Event)
}
func handleFromPtr_Ptr_model_Event(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*model.Event", p))
}

// Converters for pointer handles for type: *model.PathNode
func ptrFromHandle_Ptr_model_PathNode(h CGoHandle) *model.PathNode {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*model.PathNode")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.PathNode{})).(*model.PathNode)
}
func handleFromPtr_Ptr_model_PathNode(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*model.PathNode", p))
}

// Converters for pointer handles for type: *model.RuleResult
func ptrFromHandle_Ptr_model_RuleResult(h CGoHandle) *model.RuleResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*model.RuleResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.RuleResult{})).(*model.RuleResult)
}
func handleFromPtr_Ptr_model_RuleResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*model.RuleResult", p))
}

// Converters for pointer handles for type: *utils.RuleResolver
func ptrFromHandle_Ptr_utils_RuleResolver(h CGoHandle) *utils.RuleResolver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*utils.RuleResolver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(utils.RuleResolver{})).(*utils.RuleResolver)
}
func handleFromPtr_Ptr_utils_RuleResolver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*utils.RuleResolver", p))
}

// Converters for pointer handles for type: *utils.RuleSpec
func ptrFromHandle_Ptr_utils_RuleSpec(h CGoHandle) *utils.RuleSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*utils.RuleSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(utils.RuleSpec{})).(*utils.RuleSpec)
}
func handleFromPtr_Ptr_utils_RuleSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*utils.RuleSpec", p))
}

// Converters for pointer handles for type: *time.Location
func ptrFromHandle_Ptr_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_Ptr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Location", p))
}

// Converters for pointer handles for type: *time.Time
func ptrFromHandle_Ptr_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_Ptr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*time.Time", p))
}

// Converters for pointer handles for type: context.Context
func ptrFromHandle_context_Context(h CGoHandle) context.Context {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "context.Context")
	if p == nil {
		return nil
	}
	return p.(context.Context)
}
func handleFromPtr_context_Context(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("context.Context", p))
}

// Converters for pointer handles for type: driver.Value
func ptrFromHandle_driver_Value(h CGoHandle) driver.Value {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "driver.Value")
	if p == nil {
		return nil
	}
	return p.(driver.Value)
}
func handleFromPtr_driver_Value(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("driver.Value", p))
}

// Converters for implicit pointer handles for type: uuid.UUID
func ptrFromHandle_uuid_UUID(h CGoHandle) *uuid.UUID {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "uuid.UUID")
	if p == nil {
		return nil
	}
	return p.(*uuid.UUID)
}
func deptrFromHandle_uuid_UUID(h CGoHandle) uuid.UUID {
	p := ptrFromHandle_uuid_UUID(h)
	return *p
}
func handleFromPtr_uuid_UUID(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("uuid.UUID", p))
}

// --- wrapping slice: uuid.UUID ---
//
//export uuid_UUID_CTor
func uuid_UUID_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_uuid_UUID(&uuid.UUID{}))
}

//export uuid_UUID_len
func uuid_UUID_len(handle CGoHandle) int {
	return len(deptrFromHandle_uuid_UUID(handle))
}

//export uuid_UUID_elem
func uuid_UUID_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_uuid_UUID(handle)
	return C.char(s[_idx])
}

//export uuid_UUID_set
func uuid_UUID_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_uuid_UUID(handle)
	s[_idx] = byte(_vl)
}

// Converters for non-pointer handles for type: casemanager.Case
func ptrFromHandle_casemanager_Case(h CGoHandle) *casemanager.Case {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "casemanager.Case")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(casemanager.Case{})).(*casemanager.Case)
}
func handleFromPtr_casemanager_Case(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("casemanager.Case", p))
}

// Converters for pointer handles for type: s1_context.CaseManagerAccessor
func ptrFromHandle_s1_context_CaseManagerAccessor(h CGoHandle) s1_context.CaseManagerAccessor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "s1_context.CaseManagerAccessor")
	if p == nil {
		return nil
	}
	return p.(s1_context.CaseManagerAccessor)
}
func handleFromPtr_s1_context_CaseManagerAccessor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("s1_context.CaseManagerAccessor", p))
}

// Converters for pointer handles for type: s1_context.ClaimManagerAccessor
func ptrFromHandle_s1_context_ClaimManagerAccessor(h CGoHandle) s1_context.ClaimManagerAccessor {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "s1_context.ClaimManagerAccessor")
	if p == nil {
		return nil
	}
	return p.(s1_context.ClaimManagerAccessor)
}
func handleFromPtr_s1_context_ClaimManagerAccessor(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("s1_context.ClaimManagerAccessor", p))
}

// Converters for pointer handles for type: logging.Logger
func ptrFromHandle_logging_Logger(h CGoHandle) logging.Logger {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "logging.Logger")
	if p == nil {
		return nil
	}
	return p.(logging.Logger)
}
func handleFromPtr_logging_Logger(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("logging.Logger", p))
}

// Converters for non-pointer handles for type: model.Claim
func ptrFromHandle_model_Claim(h CGoHandle) *model.Claim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "model.Claim")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.Claim{})).(*model.Claim)
}
func handleFromPtr_model_Claim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("model.Claim", p))
}

// Converters for pointer handles for type: model.DataFrame
func ptrFromHandle_model_DataFrame(h CGoHandle) model.DataFrame {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "model.DataFrame")
	if p == nil {
		return nil
	}
	return p.(model.DataFrame)
}
func handleFromPtr_model_DataFrame(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("model.DataFrame", p))
}

// Converters for non-pointer handles for type: model.Event
func ptrFromHandle_model_Event(h CGoHandle) *model.Event {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "model.Event")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.Event{})).(*model.Event)
}
func handleFromPtr_model_Event(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("model.Event", p))
}

// Converters for non-pointer handles for type: model.PathNode
func ptrFromHandle_model_PathNode(h CGoHandle) *model.PathNode {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "model.PathNode")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.PathNode{})).(*model.PathNode)
}
func handleFromPtr_model_PathNode(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("model.PathNode", p))
}

// Converters for non-pointer handles for type: model.RuleResult
func ptrFromHandle_model_RuleResult(h CGoHandle) *model.RuleResult {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "model.RuleResult")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(model.RuleResult{})).(*model.RuleResult)
}
func handleFromPtr_model_RuleResult(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("model.RuleResult", p))
}

// Converters for non-pointer handles for type: utils.RuleResolver
func ptrFromHandle_utils_RuleResolver(h CGoHandle) *utils.RuleResolver {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "utils.RuleResolver")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(utils.RuleResolver{})).(*utils.RuleResolver)
}
func handleFromPtr_utils_RuleResolver(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("utils.RuleResolver", p))
}

// Converters for non-pointer handles for type: utils.RuleSpec
func ptrFromHandle_utils_RuleSpec(h CGoHandle) *utils.RuleSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "utils.RuleSpec")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(utils.RuleSpec{})).(*utils.RuleSpec)
}
func handleFromPtr_utils_RuleSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("utils.RuleSpec", p))
}

// Converters for non-pointer handles for type: time.Location
func ptrFromHandle_time_Location(h CGoHandle) *time.Location {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Location")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Location{})).(*time.Location)
}
func handleFromPtr_time_Location(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Location", p))
}

// Converters for non-pointer handles for type: time.Time
func ptrFromHandle_time_Time(h CGoHandle) *time.Time {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "time.Time")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(time.Time{})).(*time.Time)
}
func handleFromPtr_time_Time(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("time.Time", p))
}

// ---- Package: go ---

// ---- Types ---

// Converters for implicit pointer handles for type: []bool
func ptrFromHandle_Slice_bool(h CGoHandle) *[]bool {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]bool")
	if p == nil {
		return nil
	}
	return p.(*[]bool)
}
func deptrFromHandle_Slice_bool(h CGoHandle) []bool {
	p := ptrFromHandle_Slice_bool(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_bool(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]bool", p))
}

// --- wrapping slice: []bool ---
//
//export Slice_bool_CTor
func Slice_bool_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_bool(&[]bool{}))
}

//export Slice_bool_len
func Slice_bool_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_bool(handle))
}

//export Slice_bool_elem
func Slice_bool_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_bool(handle)
	return boolGoToPy(s[_idx])
}

//export Slice_bool_subslice
func Slice_bool_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_bool(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_bool(&ss))
}

//export Slice_bool_set
func Slice_bool_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_bool(handle)
	s[_idx] = boolPyToGo(_vl)
}

//export Slice_bool_append
func Slice_bool_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_bool(handle)
	*s = append(*s, boolPyToGo(_vl))
}

// Converters for implicit pointer handles for type: []byte
func ptrFromHandle_Slice_byte(h CGoHandle) *[]byte {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]byte")
	if p == nil {
		return nil
	}
	return p.(*[]byte)
}
func deptrFromHandle_Slice_byte(h CGoHandle) []byte {
	p := ptrFromHandle_Slice_byte(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_byte(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]byte", p))
}

// --- wrapping slice: []byte ---
//
//export Slice_byte_CTor
func Slice_byte_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_byte(&[]byte{}))
}

//export Slice_byte_len
func Slice_byte_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_byte(handle))
}

//export Slice_byte_elem
func Slice_byte_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_byte(handle)
	return C.char(s[_idx])
}

//export Slice_byte_subslice
func Slice_byte_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_byte(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_byte(&ss))
}

//export Slice_byte_set
func Slice_byte_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_byte(handle)
	s[_idx] = byte(_vl)
}

//export Slice_byte_append
func Slice_byte_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_byte(handle)
	*s = append(*s, byte(_vl))
}

//export Slice_byte_from_bytes
func Slice_byte_from_bytes(o *C.PyObject) CGoHandle {
	size := C.PyBytes_Size(o)
	ptr := unsafe.Pointer(C.PyBytes_AsString(o))
	data := make([]byte, size)
	tmp := unsafe.Slice((*byte)(ptr), size)
	copy(data, tmp)
	return handleFromPtr_Slice_byte(&data)
}

//export Slice_byte_to_bytes
func Slice_byte_to_bytes(handle CGoHandle) *C.PyObject {
	s := deptrFromHandle_Slice_byte(handle)
	ptr := unsafe.Pointer(&s[0])
	size := len(s)
	return C.PyBytes_FromStringAndSize((*C.char)(ptr), C.long(size))
}

// Converters for implicit pointer handles for type: []error
func ptrFromHandle_Slice_error(h CGoHandle) *[]error {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]error")
	if p == nil {
		return nil
	}
	return p.(*[]error)
}
func deptrFromHandle_Slice_error(h CGoHandle) []error {
	p := ptrFromHandle_Slice_error(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_error(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]error", p))
}

// --- wrapping slice: []error ---
//
//export Slice_error_CTor
func Slice_error_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_error(&[]error{}))
}

//export Slice_error_len
func Slice_error_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_error(handle))
}

//export Slice_error_elem
func Slice_error_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_error(handle)
	return errorGoToPy(s[_idx])
}

//export Slice_error_subslice
func Slice_error_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_error(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_error(&ss))
}

//export Slice_error_set
func Slice_error_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_error(handle)
	s[_idx] = errors.New(C.GoString(_vl))
}

//export Slice_error_append
func Slice_error_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_error(handle)
	*s = append(*s, errors.New(C.GoString(_vl)))
}

// Converters for implicit pointer handles for type: []float32
func ptrFromHandle_Slice_float32(h CGoHandle) *[]float32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float32")
	if p == nil {
		return nil
	}
	return p.(*[]float32)
}
func deptrFromHandle_Slice_float32(h CGoHandle) []float32 {
	p := ptrFromHandle_Slice_float32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float32", p))
}

// --- wrapping slice: []float32 ---
//
//export Slice_float32_CTor
func Slice_float32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float32(&[]float32{}))
}

//export Slice_float32_len
func Slice_float32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float32(handle))
}

//export Slice_float32_elem
func Slice_float32_elem(handle CGoHandle, _idx int) C.float {
	s := deptrFromHandle_Slice_float32(handle)
	return C.float(s[_idx])
}

//export Slice_float32_subslice
func Slice_float32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float32(&ss))
}

//export Slice_float32_set
func Slice_float32_set(handle CGoHandle, _idx int, _vl C.float) {
	s := deptrFromHandle_Slice_float32(handle)
	s[_idx] = float32(_vl)
}

//export Slice_float32_append
func Slice_float32_append(handle CGoHandle, _vl C.float) {
	s := ptrFromHandle_Slice_float32(handle)
	*s = append(*s, float32(_vl))
}

// Converters for implicit pointer handles for type: []float64
func ptrFromHandle_Slice_float64(h CGoHandle) *[]float64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]float64")
	if p == nil {
		return nil
	}
	return p.(*[]float64)
}
func deptrFromHandle_Slice_float64(h CGoHandle) []float64 {
	p := ptrFromHandle_Slice_float64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_float64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]float64", p))
}

// --- wrapping slice: []float64 ---
//
//export Slice_float64_CTor
func Slice_float64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_float64(&[]float64{}))
}

//export Slice_float64_len
func Slice_float64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_float64(handle))
}

//export Slice_float64_elem
func Slice_float64_elem(handle CGoHandle, _idx int) C.double {
	s := deptrFromHandle_Slice_float64(handle)
	return C.double(s[_idx])
}

//export Slice_float64_subslice
func Slice_float64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_float64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_float64(&ss))
}

//export Slice_float64_set
func Slice_float64_set(handle CGoHandle, _idx int, _vl C.double) {
	s := deptrFromHandle_Slice_float64(handle)
	s[_idx] = float64(_vl)
}

//export Slice_float64_append
func Slice_float64_append(handle CGoHandle, _vl C.double) {
	s := ptrFromHandle_Slice_float64(handle)
	*s = append(*s, float64(_vl))
}

// Converters for implicit pointer handles for type: []int
func ptrFromHandle_Slice_int(h CGoHandle) *[]int {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int")
	if p == nil {
		return nil
	}
	return p.(*[]int)
}
func deptrFromHandle_Slice_int(h CGoHandle) []int {
	p := ptrFromHandle_Slice_int(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int", p))
}

// --- wrapping slice: []int ---
//
//export Slice_int_CTor
func Slice_int_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int(&[]int{}))
}

//export Slice_int_len
func Slice_int_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int(handle))
}

//export Slice_int_elem
func Slice_int_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int(handle)
	return C.longlong(s[_idx])
}

//export Slice_int_subslice
func Slice_int_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int(&ss))
}

//export Slice_int_set
func Slice_int_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int(handle)
	s[_idx] = int(_vl)
}

//export Slice_int_append
func Slice_int_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int(handle)
	*s = append(*s, int(_vl))
}

// Converters for implicit pointer handles for type: []int16
func ptrFromHandle_Slice_int16(h CGoHandle) *[]int16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int16")
	if p == nil {
		return nil
	}
	return p.(*[]int16)
}
func deptrFromHandle_Slice_int16(h CGoHandle) []int16 {
	p := ptrFromHandle_Slice_int16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int16", p))
}

// --- wrapping slice: []int16 ---
//
//export Slice_int16_CTor
func Slice_int16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int16(&[]int16{}))
}

//export Slice_int16_len
func Slice_int16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int16(handle))
}

//export Slice_int16_elem
func Slice_int16_elem(handle CGoHandle, _idx int) C.short {
	s := deptrFromHandle_Slice_int16(handle)
	return C.short(s[_idx])
}

//export Slice_int16_subslice
func Slice_int16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int16(&ss))
}

//export Slice_int16_set
func Slice_int16_set(handle CGoHandle, _idx int, _vl C.short) {
	s := deptrFromHandle_Slice_int16(handle)
	s[_idx] = int16(_vl)
}

//export Slice_int16_append
func Slice_int16_append(handle CGoHandle, _vl C.short) {
	s := ptrFromHandle_Slice_int16(handle)
	*s = append(*s, int16(_vl))
}

// Converters for implicit pointer handles for type: []int32
func ptrFromHandle_Slice_int32(h CGoHandle) *[]int32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int32")
	if p == nil {
		return nil
	}
	return p.(*[]int32)
}
func deptrFromHandle_Slice_int32(h CGoHandle) []int32 {
	p := ptrFromHandle_Slice_int32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int32", p))
}

// --- wrapping slice: []int32 ---
//
//export Slice_int32_CTor
func Slice_int32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int32(&[]int32{}))
}

//export Slice_int32_len
func Slice_int32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int32(handle))
}

//export Slice_int32_elem
func Slice_int32_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_int32(handle)
	return C.long(s[_idx])
}

//export Slice_int32_subslice
func Slice_int32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int32(&ss))
}

//export Slice_int32_set
func Slice_int32_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_int32(handle)
	s[_idx] = int32(_vl)
}

//export Slice_int32_append
func Slice_int32_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_int32(handle)
	*s = append(*s, int32(_vl))
}

// Converters for implicit pointer handles for type: []int64
func ptrFromHandle_Slice_int64(h CGoHandle) *[]int64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int64")
	if p == nil {
		return nil
	}
	return p.(*[]int64)
}
func deptrFromHandle_Slice_int64(h CGoHandle) []int64 {
	p := ptrFromHandle_Slice_int64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int64", p))
}

// --- wrapping slice: []int64 ---
//
//export Slice_int64_CTor
func Slice_int64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int64(&[]int64{}))
}

//export Slice_int64_len
func Slice_int64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int64(handle))
}

//export Slice_int64_elem
func Slice_int64_elem(handle CGoHandle, _idx int) C.longlong {
	s := deptrFromHandle_Slice_int64(handle)
	return C.longlong(s[_idx])
}

//export Slice_int64_subslice
func Slice_int64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int64(&ss))
}

//export Slice_int64_set
func Slice_int64_set(handle CGoHandle, _idx int, _vl C.longlong) {
	s := deptrFromHandle_Slice_int64(handle)
	s[_idx] = int64(_vl)
}

//export Slice_int64_append
func Slice_int64_append(handle CGoHandle, _vl C.longlong) {
	s := ptrFromHandle_Slice_int64(handle)
	*s = append(*s, int64(_vl))
}

// Converters for implicit pointer handles for type: []int8
func ptrFromHandle_Slice_int8(h CGoHandle) *[]int8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]int8")
	if p == nil {
		return nil
	}
	return p.(*[]int8)
}
func deptrFromHandle_Slice_int8(h CGoHandle) []int8 {
	p := ptrFromHandle_Slice_int8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_int8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]int8", p))
}

// --- wrapping slice: []int8 ---
//
//export Slice_int8_CTor
func Slice_int8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_int8(&[]int8{}))
}

//export Slice_int8_len
func Slice_int8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_int8(handle))
}

//export Slice_int8_elem
func Slice_int8_elem(handle CGoHandle, _idx int) C.char {
	s := deptrFromHandle_Slice_int8(handle)
	return C.char(s[_idx])
}

//export Slice_int8_subslice
func Slice_int8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_int8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_int8(&ss))
}

//export Slice_int8_set
func Slice_int8_set(handle CGoHandle, _idx int, _vl C.char) {
	s := deptrFromHandle_Slice_int8(handle)
	s[_idx] = int8(_vl)
}

//export Slice_int8_append
func Slice_int8_append(handle CGoHandle, _vl C.char) {
	s := ptrFromHandle_Slice_int8(handle)
	*s = append(*s, int8(_vl))
}

// Converters for implicit pointer handles for type: []rune
func ptrFromHandle_Slice_rune(h CGoHandle) *[]rune {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]rune")
	if p == nil {
		return nil
	}
	return p.(*[]rune)
}
func deptrFromHandle_Slice_rune(h CGoHandle) []rune {
	p := ptrFromHandle_Slice_rune(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_rune(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]rune", p))
}

// --- wrapping slice: []rune ---
//
//export Slice_rune_CTor
func Slice_rune_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_rune(&[]rune{}))
}

//export Slice_rune_len
func Slice_rune_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_rune(handle))
}

//export Slice_rune_elem
func Slice_rune_elem(handle CGoHandle, _idx int) C.long {
	s := deptrFromHandle_Slice_rune(handle)
	return C.long(s[_idx])
}

//export Slice_rune_subslice
func Slice_rune_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_rune(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_rune(&ss))
}

//export Slice_rune_set
func Slice_rune_set(handle CGoHandle, _idx int, _vl C.long) {
	s := deptrFromHandle_Slice_rune(handle)
	s[_idx] = rune(_vl)
}

//export Slice_rune_append
func Slice_rune_append(handle CGoHandle, _vl C.long) {
	s := ptrFromHandle_Slice_rune(handle)
	*s = append(*s, rune(_vl))
}

// Converters for implicit pointer handles for type: []string
func ptrFromHandle_Slice_string(h CGoHandle) *[]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]string")
	if p == nil {
		return nil
	}
	return p.(*[]string)
}
func deptrFromHandle_Slice_string(h CGoHandle) []string {
	p := ptrFromHandle_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]string", p))
}

// --- wrapping slice: []string ---
//
//export Slice_string_CTor
func Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_string(&[]string{}))
}

//export Slice_string_len
func Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_string(handle))
}

//export Slice_string_elem
func Slice_string_elem(handle CGoHandle, _idx int) *C.char {
	s := deptrFromHandle_Slice_string(handle)
	return C.CString(s[_idx])
}

//export Slice_string_subslice
func Slice_string_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_string(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_string(&ss))
}

//export Slice_string_set
func Slice_string_set(handle CGoHandle, _idx int, _vl *C.char) {
	s := deptrFromHandle_Slice_string(handle)
	s[_idx] = C.GoString(_vl)
}

//export Slice_string_append
func Slice_string_append(handle CGoHandle, _vl *C.char) {
	s := ptrFromHandle_Slice_string(handle)
	*s = append(*s, C.GoString(_vl))
}

// Converters for implicit pointer handles for type: []uint
func ptrFromHandle_Slice_uint(h CGoHandle) *[]uint {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint")
	if p == nil {
		return nil
	}
	return p.(*[]uint)
}
func deptrFromHandle_Slice_uint(h CGoHandle) []uint {
	p := ptrFromHandle_Slice_uint(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint", p))
}

// --- wrapping slice: []uint ---
//
//export Slice_uint_CTor
func Slice_uint_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint(&[]uint{}))
}

//export Slice_uint_len
func Slice_uint_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint(handle))
}

//export Slice_uint_elem
func Slice_uint_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint_subslice
func Slice_uint_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint(&ss))
}

//export Slice_uint_set
func Slice_uint_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint(handle)
	s[_idx] = uint(_vl)
}

//export Slice_uint_append
func Slice_uint_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint(handle)
	*s = append(*s, uint(_vl))
}

// Converters for implicit pointer handles for type: []uint16
func ptrFromHandle_Slice_uint16(h CGoHandle) *[]uint16 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint16")
	if p == nil {
		return nil
	}
	return p.(*[]uint16)
}
func deptrFromHandle_Slice_uint16(h CGoHandle) []uint16 {
	p := ptrFromHandle_Slice_uint16(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint16(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint16", p))
}

// --- wrapping slice: []uint16 ---
//
//export Slice_uint16_CTor
func Slice_uint16_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint16(&[]uint16{}))
}

//export Slice_uint16_len
func Slice_uint16_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint16(handle))
}

//export Slice_uint16_elem
func Slice_uint16_elem(handle CGoHandle, _idx int) C.ushort {
	s := deptrFromHandle_Slice_uint16(handle)
	return C.ushort(s[_idx])
}

//export Slice_uint16_subslice
func Slice_uint16_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint16(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint16(&ss))
}

//export Slice_uint16_set
func Slice_uint16_set(handle CGoHandle, _idx int, _vl C.ushort) {
	s := deptrFromHandle_Slice_uint16(handle)
	s[_idx] = uint16(_vl)
}

//export Slice_uint16_append
func Slice_uint16_append(handle CGoHandle, _vl C.ushort) {
	s := ptrFromHandle_Slice_uint16(handle)
	*s = append(*s, uint16(_vl))
}

// Converters for implicit pointer handles for type: []uint32
func ptrFromHandle_Slice_uint32(h CGoHandle) *[]uint32 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint32")
	if p == nil {
		return nil
	}
	return p.(*[]uint32)
}
func deptrFromHandle_Slice_uint32(h CGoHandle) []uint32 {
	p := ptrFromHandle_Slice_uint32(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint32(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint32", p))
}

// --- wrapping slice: []uint32 ---
//
//export Slice_uint32_CTor
func Slice_uint32_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint32(&[]uint32{}))
}

//export Slice_uint32_len
func Slice_uint32_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint32(handle))
}

//export Slice_uint32_elem
func Slice_uint32_elem(handle CGoHandle, _idx int) C.ulong {
	s := deptrFromHandle_Slice_uint32(handle)
	return C.ulong(s[_idx])
}

//export Slice_uint32_subslice
func Slice_uint32_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint32(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint32(&ss))
}

//export Slice_uint32_set
func Slice_uint32_set(handle CGoHandle, _idx int, _vl C.ulong) {
	s := deptrFromHandle_Slice_uint32(handle)
	s[_idx] = uint32(_vl)
}

//export Slice_uint32_append
func Slice_uint32_append(handle CGoHandle, _vl C.ulong) {
	s := ptrFromHandle_Slice_uint32(handle)
	*s = append(*s, uint32(_vl))
}

// Converters for implicit pointer handles for type: []uint64
func ptrFromHandle_Slice_uint64(h CGoHandle) *[]uint64 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint64")
	if p == nil {
		return nil
	}
	return p.(*[]uint64)
}
func deptrFromHandle_Slice_uint64(h CGoHandle) []uint64 {
	p := ptrFromHandle_Slice_uint64(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint64(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint64", p))
}

// --- wrapping slice: []uint64 ---
//
//export Slice_uint64_CTor
func Slice_uint64_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint64(&[]uint64{}))
}

//export Slice_uint64_len
func Slice_uint64_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint64(handle))
}

//export Slice_uint64_elem
func Slice_uint64_elem(handle CGoHandle, _idx int) C.ulonglong {
	s := deptrFromHandle_Slice_uint64(handle)
	return C.ulonglong(s[_idx])
}

//export Slice_uint64_subslice
func Slice_uint64_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint64(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint64(&ss))
}

//export Slice_uint64_set
func Slice_uint64_set(handle CGoHandle, _idx int, _vl C.ulonglong) {
	s := deptrFromHandle_Slice_uint64(handle)
	s[_idx] = uint64(_vl)
}

//export Slice_uint64_append
func Slice_uint64_append(handle CGoHandle, _vl C.ulonglong) {
	s := ptrFromHandle_Slice_uint64(handle)
	*s = append(*s, uint64(_vl))
}

// Converters for implicit pointer handles for type: []uint8
func ptrFromHandle_Slice_uint8(h CGoHandle) *[]uint8 {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]uint8")
	if p == nil {
		return nil
	}
	return p.(*[]uint8)
}
func deptrFromHandle_Slice_uint8(h CGoHandle) []uint8 {
	p := ptrFromHandle_Slice_uint8(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_uint8(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]uint8", p))
}

// --- wrapping slice: []uint8 ---
//
//export Slice_uint8_CTor
func Slice_uint8_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_uint8(&[]uint8{}))
}

//export Slice_uint8_len
func Slice_uint8_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_uint8(handle))
}

//export Slice_uint8_elem
func Slice_uint8_elem(handle CGoHandle, _idx int) C.uchar {
	s := deptrFromHandle_Slice_uint8(handle)
	return C.uchar(s[_idx])
}

//export Slice_uint8_subslice
func Slice_uint8_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_uint8(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_uint8(&ss))
}

//export Slice_uint8_set
func Slice_uint8_set(handle CGoHandle, _idx int, _vl C.uchar) {
	s := deptrFromHandle_Slice_uint8(handle)
	s[_idx] = uint8(_vl)
}

//export Slice_uint8_append
func Slice_uint8_append(handle CGoHandle, _vl C.uchar) {
	s := ptrFromHandle_Slice_uint8(handle)
	*s = append(*s, uint8(_vl))
}

// ---- Package: service ---

// ---- Types ---

// Converters for pointer handles for type: *service.CaseManager
func ptrFromHandle_Ptr_service_CaseManager(h CGoHandle) *service.CaseManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*service.CaseManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager)
}
func handleFromPtr_Ptr_service_CaseManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*service.CaseManager", p))
}

// Converters for pointer handles for type: *service.ClaimManager
func ptrFromHandle_Ptr_service_ClaimManager(h CGoHandle) *service.ClaimManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*service.ClaimManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager)
}
func handleFromPtr_Ptr_service_ClaimManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*service.ClaimManager", p))
}

// Converters for pointer handles for type: *service.RuleService
func ptrFromHandle_Ptr_service_RuleService(h CGoHandle) *service.RuleService {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*service.RuleService")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.RuleService{})).(*service.RuleService)
}
func handleFromPtr_Ptr_service_RuleService(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*service.RuleService", p))
}

// Converters for pointer handles for type: *service.Services
func ptrFromHandle_Ptr_service_Services(h CGoHandle) *service.Services {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "*service.Services")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.Services{})).(*service.Services)
}
func handleFromPtr_Ptr_service_Services(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("*service.Services", p))
}

// Converters for implicit pointer handles for type: []*casemanager.Case
func ptrFromHandle_Slice_Ptr_casemanager_Case(h CGoHandle) *[]*casemanager.Case {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*casemanager.Case")
	if p == nil {
		return nil
	}
	return p.(*[]*casemanager.Case)
}
func deptrFromHandle_Slice_Ptr_casemanager_Case(h CGoHandle) []*casemanager.Case {
	p := ptrFromHandle_Slice_Ptr_casemanager_Case(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_casemanager_Case(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*casemanager.Case", p))
}

// --- wrapping slice: []*casemanager.Case ---
//
//export Slice_Ptr_casemanager_Case_CTor
func Slice_Ptr_casemanager_Case_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_casemanager_Case(&[]*casemanager.Case{}))
}

//export Slice_Ptr_casemanager_Case_len
func Slice_Ptr_casemanager_Case_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_casemanager_Case(handle))
}

//export Slice_Ptr_casemanager_Case_elem
func Slice_Ptr_casemanager_Case_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_casemanager_Case(handle)
	return handleFromPtr_Ptr_casemanager_Case(&(s[_idx]))
}

//export Slice_Ptr_casemanager_Case_subslice
func Slice_Ptr_casemanager_Case_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_casemanager_Case(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_casemanager_Case(&ss))
}

//export Slice_Ptr_casemanager_Case_set
func Slice_Ptr_casemanager_Case_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_casemanager_Case(handle)
	s[_idx] = ptrFromHandle_Ptr_casemanager_Case(_vl)
}

//export Slice_Ptr_casemanager_Case_append
func Slice_Ptr_casemanager_Case_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_casemanager_Case(handle)
	*s = append(*s, ptrFromHandle_Ptr_casemanager_Case(_vl))
}

// Converters for implicit pointer handles for type: []*model.Claim
func ptrFromHandle_Slice_Ptr_model_Claim(h CGoHandle) *[]*model.Claim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*model.Claim")
	if p == nil {
		return nil
	}
	return p.(*[]*model.Claim)
}
func deptrFromHandle_Slice_Ptr_model_Claim(h CGoHandle) []*model.Claim {
	p := ptrFromHandle_Slice_Ptr_model_Claim(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_model_Claim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*model.Claim", p))
}

// --- wrapping slice: []*model.Claim ---
//
//export Slice_Ptr_model_Claim_CTor
func Slice_Ptr_model_Claim_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_model_Claim(&[]*model.Claim{}))
}

//export Slice_Ptr_model_Claim_len
func Slice_Ptr_model_Claim_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_model_Claim(handle))
}

//export Slice_Ptr_model_Claim_elem
func Slice_Ptr_model_Claim_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_Claim(handle)
	return handleFromPtr_Ptr_model_Claim(&(s[_idx]))
}

//export Slice_Ptr_model_Claim_subslice
func Slice_Ptr_model_Claim_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_Claim(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_model_Claim(&ss))
}

//export Slice_Ptr_model_Claim_set
func Slice_Ptr_model_Claim_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_model_Claim(handle)
	s[_idx] = ptrFromHandle_Ptr_model_Claim(_vl)
}

//export Slice_Ptr_model_Claim_append
func Slice_Ptr_model_Claim_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_model_Claim(handle)
	*s = append(*s, ptrFromHandle_Ptr_model_Claim(_vl))
}

// Converters for implicit pointer handles for type: []*model.Event
func ptrFromHandle_Slice_Ptr_model_Event(h CGoHandle) *[]*model.Event {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*model.Event")
	if p == nil {
		return nil
	}
	return p.(*[]*model.Event)
}
func deptrFromHandle_Slice_Ptr_model_Event(h CGoHandle) []*model.Event {
	p := ptrFromHandle_Slice_Ptr_model_Event(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_model_Event(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*model.Event", p))
}

// --- wrapping slice: []*model.Event ---
//
//export Slice_Ptr_model_Event_CTor
func Slice_Ptr_model_Event_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_model_Event(&[]*model.Event{}))
}

//export Slice_Ptr_model_Event_len
func Slice_Ptr_model_Event_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_model_Event(handle))
}

//export Slice_Ptr_model_Event_elem
func Slice_Ptr_model_Event_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_Event(handle)
	return handleFromPtr_Ptr_model_Event(&(s[_idx]))
}

//export Slice_Ptr_model_Event_subslice
func Slice_Ptr_model_Event_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_Event(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_model_Event(&ss))
}

//export Slice_Ptr_model_Event_set
func Slice_Ptr_model_Event_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_model_Event(handle)
	s[_idx] = ptrFromHandle_Ptr_model_Event(_vl)
}

//export Slice_Ptr_model_Event_append
func Slice_Ptr_model_Event_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_model_Event(handle)
	*s = append(*s, ptrFromHandle_Ptr_model_Event(_vl))
}

// Converters for implicit pointer handles for type: []*model.PathNode
func ptrFromHandle_Slice_Ptr_model_PathNode(h CGoHandle) *[]*model.PathNode {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*model.PathNode")
	if p == nil {
		return nil
	}
	return p.(*[]*model.PathNode)
}
func deptrFromHandle_Slice_Ptr_model_PathNode(h CGoHandle) []*model.PathNode {
	p := ptrFromHandle_Slice_Ptr_model_PathNode(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_model_PathNode(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*model.PathNode", p))
}

// --- wrapping slice: []*model.PathNode ---
//
//export Slice_Ptr_model_PathNode_CTor
func Slice_Ptr_model_PathNode_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_model_PathNode(&[]*model.PathNode{}))
}

//export Slice_Ptr_model_PathNode_len
func Slice_Ptr_model_PathNode_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_model_PathNode(handle))
}

//export Slice_Ptr_model_PathNode_elem
func Slice_Ptr_model_PathNode_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_PathNode(handle)
	return handleFromPtr_Ptr_model_PathNode(&(s[_idx]))
}

//export Slice_Ptr_model_PathNode_subslice
func Slice_Ptr_model_PathNode_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_model_PathNode(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_model_PathNode(&ss))
}

//export Slice_Ptr_model_PathNode_set
func Slice_Ptr_model_PathNode_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_model_PathNode(handle)
	s[_idx] = ptrFromHandle_Ptr_model_PathNode(_vl)
}

//export Slice_Ptr_model_PathNode_append
func Slice_Ptr_model_PathNode_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_model_PathNode(handle)
	*s = append(*s, ptrFromHandle_Ptr_model_PathNode(_vl))
}

// Converters for implicit pointer handles for type: []*utils.RuleSpec
func ptrFromHandle_Slice_Ptr_utils_RuleSpec(h CGoHandle) *[]*utils.RuleSpec {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]*utils.RuleSpec")
	if p == nil {
		return nil
	}
	return p.(*[]*utils.RuleSpec)
}
func deptrFromHandle_Slice_Ptr_utils_RuleSpec(h CGoHandle) []*utils.RuleSpec {
	p := ptrFromHandle_Slice_Ptr_utils_RuleSpec(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Ptr_utils_RuleSpec(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]*utils.RuleSpec", p))
}

// --- wrapping slice: []*utils.RuleSpec ---
//
//export Slice_Ptr_utils_RuleSpec_CTor
func Slice_Ptr_utils_RuleSpec_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Ptr_utils_RuleSpec(&[]*utils.RuleSpec{}))
}

//export Slice_Ptr_utils_RuleSpec_len
func Slice_Ptr_utils_RuleSpec_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Ptr_utils_RuleSpec(handle))
}

//export Slice_Ptr_utils_RuleSpec_elem
func Slice_Ptr_utils_RuleSpec_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_utils_RuleSpec(handle)
	return handleFromPtr_Ptr_utils_RuleSpec(&(s[_idx]))
}

//export Slice_Ptr_utils_RuleSpec_subslice
func Slice_Ptr_utils_RuleSpec_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Ptr_utils_RuleSpec(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Ptr_utils_RuleSpec(&ss))
}

//export Slice_Ptr_utils_RuleSpec_set
func Slice_Ptr_utils_RuleSpec_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Ptr_utils_RuleSpec(handle)
	s[_idx] = ptrFromHandle_Ptr_utils_RuleSpec(_vl)
}

//export Slice_Ptr_utils_RuleSpec_append
func Slice_Ptr_utils_RuleSpec_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Ptr_utils_RuleSpec(handle)
	*s = append(*s, ptrFromHandle_Ptr_utils_RuleSpec(_vl))
}

// Converters for implicit pointer handles for type: []map[string]any
func ptrFromHandle_Slice_Map_string_any(h CGoHandle) *[]map[string]any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "[]map[string]any")
	if p == nil {
		return nil
	}
	return p.(*[]map[string]any)
}
func deptrFromHandle_Slice_Map_string_any(h CGoHandle) []map[string]any {
	p := ptrFromHandle_Slice_Map_string_any(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Slice_Map_string_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("[]map[string]any", p))
}

// --- wrapping slice: []map[string]any ---
//
//export Slice_Map_string_any_CTor
func Slice_Map_string_any_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Slice_Map_string_any(&[]map[string]any{}))
}

//export Slice_Map_string_any_len
func Slice_Map_string_any_len(handle CGoHandle) int {
	return len(deptrFromHandle_Slice_Map_string_any(handle))
}

//export Slice_Map_string_any_elem
func Slice_Map_string_any_elem(handle CGoHandle, _idx int) CGoHandle {
	s := deptrFromHandle_Slice_Map_string_any(handle)
	return handleFromPtr_Map_string_any(&(s[_idx]))
}

//export Slice_Map_string_any_subslice
func Slice_Map_string_any_subslice(handle CGoHandle, _st, _ed int) CGoHandle {
	s := deptrFromHandle_Slice_Map_string_any(handle)
	ss := s[_st:_ed]
	return CGoHandle(handleFromPtr_Slice_Map_string_any(&ss))
}

//export Slice_Map_string_any_set
func Slice_Map_string_any_set(handle CGoHandle, _idx int, _vl CGoHandle) {
	s := deptrFromHandle_Slice_Map_string_any(handle)
	s[_idx] = deptrFromHandle_Map_string_any(_vl)
}

//export Slice_Map_string_any_append
func Slice_Map_string_any_append(handle CGoHandle, _vl CGoHandle) {
	s := ptrFromHandle_Slice_Map_string_any(handle)
	*s = append(*s, deptrFromHandle_Map_string_any(_vl))
}

// Converters for pointer handles for type: any
func ptrFromHandle_any(h CGoHandle) any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "any")
	if p == nil {
		return nil
	}
	return p.(any)
}
func handleFromPtr_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("any", p))
}

// Converters for non-pointer handles for type: service.CaseManager
func ptrFromHandle_service_CaseManager(h CGoHandle) *service.CaseManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "service.CaseManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager)
}
func handleFromPtr_service_CaseManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("service.CaseManager", p))
}

// Converters for non-pointer handles for type: service.ClaimManager
func ptrFromHandle_service_ClaimManager(h CGoHandle) *service.ClaimManager {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "service.ClaimManager")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager)
}
func handleFromPtr_service_ClaimManager(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("service.ClaimManager", p))
}

// Converters for non-pointer handles for type: service.RuleService
func ptrFromHandle_service_RuleService(h CGoHandle) *service.RuleService {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "service.RuleService")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.RuleService{})).(*service.RuleService)
}
func handleFromPtr_service_RuleService(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("service.RuleService", p))
}

// Converters for non-pointer handles for type: service.Services
func ptrFromHandle_service_Services(h CGoHandle) *service.Services {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "service.Services")
	if p == nil {
		return nil
	}
	return gopyh.Embed(p, reflect.TypeOf(service.Services{})).(*service.Services)
}
func handleFromPtr_service_Services(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("service.Services", p))
}

// Converters for implicit pointer handles for type: map[string]*model.Claim
func ptrFromHandle_Map_string_Ptr_model_Claim(h CGoHandle) *map[string]*model.Claim {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]*model.Claim")
	if p == nil {
		return nil
	}
	return p.(*map[string]*model.Claim)
}
func deptrFromHandle_Map_string_Ptr_model_Claim(h CGoHandle) map[string]*model.Claim {
	p := ptrFromHandle_Map_string_Ptr_model_Claim(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Ptr_model_Claim(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]*model.Claim", p))
}

// --- wrapping map: map[string]*model.Claim ---
//
//export Map_string_Ptr_model_Claim_CTor
func Map_string_Ptr_model_Claim_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Ptr_model_Claim(&map[string]*model.Claim{}))
}

//export Map_string_Ptr_model_Claim_len
func Map_string_Ptr_model_Claim_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Ptr_model_Claim(handle))
}

//export Map_string_Ptr_model_Claim_elem
func Map_string_Ptr_model_Claim_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_model_Claim(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Ptr_model_Claim(&v)
}

//export Map_string_Ptr_model_Claim_contains
func Map_string_Ptr_model_Claim_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Ptr_model_Claim(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Ptr_model_Claim_set
func Map_string_Ptr_model_Claim_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Ptr_model_Claim(handle)
	s[C.GoString(_ky)] = ptrFromHandle_Ptr_model_Claim(_vl)
}

//export Map_string_Ptr_model_Claim_delete
func Map_string_Ptr_model_Claim_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Ptr_model_Claim(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Ptr_model_Claim_keys
func Map_string_Ptr_model_Claim_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Ptr_model_Claim(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string][]string
func ptrFromHandle_Map_string_Slice_string(h CGoHandle) *map[string][]string {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string][]string")
	if p == nil {
		return nil
	}
	return p.(*map[string][]string)
}
func deptrFromHandle_Map_string_Slice_string(h CGoHandle) map[string][]string {
	p := ptrFromHandle_Map_string_Slice_string(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Slice_string(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string][]string", p))
}

// --- wrapping map: map[string][]string ---
//
//export Map_string_Slice_string_CTor
func Map_string_Slice_string_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Slice_string(&map[string][]string{}))
}

//export Map_string_Slice_string_len
func Map_string_Slice_string_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Slice_string(handle))
}

//export Map_string_Slice_string_elem
func Map_string_Slice_string_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Slice_string(&v)
}

//export Map_string_Slice_string_contains
func Map_string_Slice_string_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Slice_string_set
func Map_string_Slice_string_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Slice_string(_vl)
}

//export Map_string_Slice_string_delete
func Map_string_Slice_string_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Slice_string_keys
func Map_string_Slice_string_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Slice_string(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]any
func ptrFromHandle_Map_string_any(h CGoHandle) *map[string]any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]any")
	if p == nil {
		return nil
	}
	return p.(*map[string]any)
}
func deptrFromHandle_Map_string_any(h CGoHandle) map[string]any {
	p := ptrFromHandle_Map_string_any(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]any", p))
}

// --- wrapping map: map[string]any ---
//
//export Map_string_any_CTor
func Map_string_any_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_any(&map[string]any{}))
}

//export Map_string_any_len
func Map_string_any_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_any(handle))
}

//export Map_string_any_elem
func Map_string_any_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_any(&v)
}

//export Map_string_any_contains
func Map_string_any_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_any(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_any_set
func Map_string_any_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_any(handle)
	s[C.GoString(_ky)] = ptrFromHandle_any(_vl)
}

//export Map_string_any_delete
func Map_string_any_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_any(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_any_keys
func Map_string_any_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_any(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]model.DataFrame
func ptrFromHandle_Map_string_model_DataFrame(h CGoHandle) *map[string]model.DataFrame {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]model.DataFrame")
	if p == nil {
		return nil
	}
	return p.(*map[string]model.DataFrame)
}
func deptrFromHandle_Map_string_model_DataFrame(h CGoHandle) map[string]model.DataFrame {
	p := ptrFromHandle_Map_string_model_DataFrame(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_model_DataFrame(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]model.DataFrame", p))
}

// --- wrapping map: map[string]model.DataFrame ---
//
//export Map_string_model_DataFrame_CTor
func Map_string_model_DataFrame_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_model_DataFrame(&map[string]model.DataFrame{}))
}

//export Map_string_model_DataFrame_len
func Map_string_model_DataFrame_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_model_DataFrame(handle))
}

//export Map_string_model_DataFrame_elem
func Map_string_model_DataFrame_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_model_DataFrame(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_model_DataFrame(&v)
}

//export Map_string_model_DataFrame_contains
func Map_string_model_DataFrame_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_model_DataFrame(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_model_DataFrame_set
func Map_string_model_DataFrame_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_model_DataFrame(handle)
	s[C.GoString(_ky)] = ptrFromHandle_model_DataFrame(_vl)
}

//export Map_string_model_DataFrame_delete
func Map_string_model_DataFrame_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_model_DataFrame(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_model_DataFrame_keys
func Map_string_model_DataFrame_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_model_DataFrame(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// Converters for implicit pointer handles for type: map[string]map[string]any
func ptrFromHandle_Map_string_Map_string_any(h CGoHandle) *map[string]map[string]any {
	p := gopyh.VarFromHandle((gopyh.CGoHandle)(h), "map[string]map[string]any")
	if p == nil {
		return nil
	}
	return p.(*map[string]map[string]any)
}
func deptrFromHandle_Map_string_Map_string_any(h CGoHandle) map[string]map[string]any {
	p := ptrFromHandle_Map_string_Map_string_any(h)
	if p == nil {
		return nil
	}
	return *p
}
func handleFromPtr_Map_string_Map_string_any(p interface{}) CGoHandle {
	return CGoHandle(gopyh.Register("map[string]map[string]any", p))
}

// --- wrapping map: map[string]map[string]any ---
//
//export Map_string_Map_string_any_CTor
func Map_string_Map_string_any_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_Map_string_Map_string_any(&map[string]map[string]any{}))
}

//export Map_string_Map_string_any_len
func Map_string_Map_string_any_len(handle CGoHandle) int {
	return len(deptrFromHandle_Map_string_Map_string_any(handle))
}

//export Map_string_Map_string_any_elem
func Map_string_Map_string_any_elem(handle CGoHandle, _ky *C.char) CGoHandle {
	s := deptrFromHandle_Map_string_Map_string_any(handle)
	v, ok := s[C.GoString(_ky)]
	if !ok {
		C.PyErr_SetString(C.PyExc_KeyError, C.CString("key not in map"))
	}
	return handleFromPtr_Map_string_any(&v)
}

//export Map_string_Map_string_any_contains
func Map_string_Map_string_any_contains(handle CGoHandle, _ky *C.char) C.char {
	s := deptrFromHandle_Map_string_Map_string_any(handle)
	_, ok := s[C.GoString(_ky)]
	return boolGoToPy(ok)
}

//export Map_string_Map_string_any_set
func Map_string_Map_string_any_set(handle CGoHandle, _ky *C.char, _vl CGoHandle) {
	s := deptrFromHandle_Map_string_Map_string_any(handle)
	s[C.GoString(_ky)] = deptrFromHandle_Map_string_any(_vl)
}

//export Map_string_Map_string_any_delete
func Map_string_Map_string_any_delete(handle CGoHandle, _ky *C.char) {
	s := deptrFromHandle_Map_string_Map_string_any(handle)
	delete(s, C.GoString(_ky))
}

//export Map_string_Map_string_any_keys
func Map_string_Map_string_any_keys(handle CGoHandle) CGoHandle {
	s := deptrFromHandle_Map_string_Map_string_any(handle)
	kys := make([]string, 0, len(s))
	for k := range s {
		kys = append(kys, k)
	}
	return handleFromPtr_Slice_string(&kys)
}

// ---- Global Variables: can only use functions to access ---

// ---- Interfaces ---

// ---- Structs ---

// --- wrapping struct: service.CaseManager ---
//
//export service_CaseManager_CTor
func service_CaseManager_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_service_CaseManager(&service.CaseManager{}))
}

//export service_CaseManager_Services_Get
func service_CaseManager_Services_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_CaseManager(handle)
	return handleFromPtr_Ptr_service_Services(op.Services)
}

//export service_CaseManager_Services_Set
func service_CaseManager_Services_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_CaseManager(handle)
	op.Services = ptrFromHandle_Ptr_service_Services(val)
}

//export service_CaseManager_SampleRate_Get
func service_CaseManager_SampleRate_Get(handle CGoHandle) C.double {
	op := ptrFromHandle_service_CaseManager(handle)
	return C.double(op.SampleRate)
}

//export service_CaseManager_SampleRate_Set
func service_CaseManager_SampleRate_Set(handle CGoHandle, val C.double) {
	op := ptrFromHandle_service_CaseManager(handle)
	op.SampleRate = float64(val)
}

//export service_CaseManager_SetCase
func service_CaseManager_SetCase(_handle CGoHandle, caseID CGoHandle, key *C.char, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).SetCase(deptrFromHandle_uuid_UUID(caseID), C.GoString(key))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).SetCase(deptrFromHandle_uuid_UUID(caseID), C.GoString(key))
	}
}

//export service_CaseManager_SubmitCase
func service_CaseManager_SubmitCase(_handle CGoHandle, ctx CGoHandle, bsn *C.char, serviceType *C.char, law *C.char, parameters CGoHandle, claimedResult CGoHandle, approvedClaimsOnly C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_uuid_UUID(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).SubmitCase(ptrFromHandle_context_Context(ctx), C.GoString(bsn), C.GoString(serviceType), C.GoString(law), deptrFromHandle_Map_string_any(parameters), deptrFromHandle_Map_string_any(claimedResult), boolPyToGo(approvedClaimsOnly))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_uuid_UUID(nil)
	}
	return handleFromPtr_uuid_UUID(&cret)
}

//export service_CaseManager_CompleteManualReview
func service_CaseManager_CompleteManualReview(_handle CGoHandle, ctx CGoHandle, caseID CGoHandle, verifierID *C.char, approved C.char, reason *C.char, overrideResult CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).CompleteManualReview(ptrFromHandle_context_Context(ctx), deptrFromHandle_uuid_UUID(caseID), C.GoString(verifierID), boolPyToGo(approved), C.GoString(reason), deptrFromHandle_Map_string_any(overrideResult))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_CaseManager_ObjectCase
func service_CaseManager_ObjectCase(_handle CGoHandle, ctx CGoHandle, caseID CGoHandle, reason *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).ObjectCase(ptrFromHandle_context_Context(ctx), deptrFromHandle_uuid_UUID(caseID), C.GoString(reason))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_CaseManager_CanAppeal
func service_CaseManager_CanAppeal(_handle CGoHandle, caseID CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).CanAppeal(deptrFromHandle_uuid_UUID(caseID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export service_CaseManager_CanObject
func service_CaseManager_CanObject(_handle CGoHandle, caseID CGoHandle) C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return boolGoToPy(false)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).CanObject(deptrFromHandle_uuid_UUID(caseID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return boolGoToPy(false)
	}
	return boolGoToPy(cret)
}

//export service_CaseManager_GetCase
func service_CaseManager_GetCase(_handle CGoHandle, bsn *C.char, serviceType *C.char, law *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Ptr_casemanager_Case(nil)
	}
	return handleFromPtr_Ptr_casemanager_Case(gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetCase(C.GoString(bsn), C.GoString(serviceType), C.GoString(law)))

}

//export service_CaseManager_GetCaseByID
func service_CaseManager_GetCaseByID(_handle CGoHandle, ctx CGoHandle, id CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Ptr_casemanager_Case(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetCaseByID(ptrFromHandle_context_Context(ctx), deptrFromHandle_uuid_UUID(id))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_casemanager_Case(nil)
	}
	return handleFromPtr_Ptr_casemanager_Case(cret)
}

//export service_CaseManager_GetCasesByStatus
func service_CaseManager_GetCasesByStatus(_handle CGoHandle, serviceType *C.char, status *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_casemanager_Case(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetCasesByStatus(C.GoString(serviceType), casemanager.CaseStatus(C.GoString(status)))

	return handleFromPtr_Slice_Ptr_casemanager_Case(&cret)
}

//export service_CaseManager_GetCasesByLaw
func service_CaseManager_GetCasesByLaw(_handle CGoHandle, law *C.char, serviceType *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_casemanager_Case(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetCasesByLaw(C.GoString(law), C.GoString(serviceType))

	return handleFromPtr_Slice_Ptr_casemanager_Case(&cret)
}

//export service_CaseManager_GetEventsByUUID
func service_CaseManager_GetEventsByUUID(_handle CGoHandle, caseID CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_model_Event(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetEventsByUUID(deptrFromHandle_uuid_UUID(caseID))

	return handleFromPtr_Slice_Ptr_model_Event(&cret)
}

//export service_CaseManager_GetEvents
func service_CaseManager_GetEvents(_handle CGoHandle, caseID CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return handleFromPtr_Slice_Map_string_any(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).GetEvents(ptrFromHandle_any(caseID))

	return handleFromPtr_Slice_Map_string_any(&cret)
}

//export service_CaseManager_Save
func service_CaseManager_Save(_handle CGoHandle, ctx CGoHandle, c CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).Save(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_casemanager_Case(c))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_CaseManager_Wait
func service_CaseManager_Wait(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).Wait()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).Wait()
	}
}

//export service_CaseManager_Close
func service_CaseManager_Close(_handle CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.CaseManager")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).Close()
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(service.CaseManager{})).(*service.CaseManager).Close()
	}
}

// --- wrapping struct: service.ClaimManager ---
//
//export service_ClaimManager_CTor
func service_ClaimManager_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_service_ClaimManager(&service.ClaimManager{}))
}

//export service_ClaimManager_Services_Get
func service_ClaimManager_Services_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_ClaimManager(handle)
	return handleFromPtr_Ptr_service_Services(op.Services)
}

//export service_ClaimManager_Services_Set
func service_ClaimManager_Services_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_ClaimManager(handle)
	op.Services = ptrFromHandle_Ptr_service_Services(val)
}

//export service_ClaimManager_CaseManager_Get
func service_ClaimManager_CaseManager_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_ClaimManager(handle)
	return handleFromPtr_Ptr_service_CaseManager(op.CaseManager)
}

//export service_ClaimManager_CaseManager_Set
func service_ClaimManager_CaseManager_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_ClaimManager(handle)
	op.CaseManager = ptrFromHandle_Ptr_service_CaseManager(val)
}

//export service_ClaimManager_SubmitClaim
func service_ClaimManager_SubmitClaim(_handle CGoHandle, ctx CGoHandle, svc *C.char, key *C.char, newValue CGoHandle, reason *C.char, claimant *C.char, law *C.char, bsn *C.char, caseID CGoHandle, oldValue CGoHandle, evidencePath *C.char, autoApprove C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return C.CString("")
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).SubmitClaim(ptrFromHandle_context_Context(ctx), C.GoString(svc), C.GoString(key), ptrFromHandle_any(newValue), C.GoString(reason), C.GoString(claimant), C.GoString(law), C.GoString(bsn), deptrFromHandle_uuid_UUID(caseID), ptrFromHandle_any(oldValue), C.GoString(evidencePath), boolPyToGo(autoApprove))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return C.CString("")
	}
	return C.CString(cret)
}

//export service_ClaimManager_ApproveClaim
func service_ClaimManager_ApproveClaim(_handle CGoHandle, ctx CGoHandle, claimID *C.char, verifiedBy *C.char, verifiedValue CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).ApproveClaim(ptrFromHandle_context_Context(ctx), C.GoString(claimID), C.GoString(verifiedBy), ptrFromHandle_any(verifiedValue))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_ClaimManager_RejectClaim
func service_ClaimManager_RejectClaim(_handle CGoHandle, ctx CGoHandle, claimID *C.char, rejectedBy *C.char, rejectionReason *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).RejectClaim(ptrFromHandle_context_Context(ctx), C.GoString(claimID), C.GoString(rejectedBy), C.GoString(rejectionReason))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_ClaimManager_LinkCase
func service_ClaimManager_LinkCase(_handle CGoHandle, claimID *C.char, caseID CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).LinkCase(C.GoString(claimID), deptrFromHandle_uuid_UUID(caseID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_ClaimManager_AddEvidence
func service_ClaimManager_AddEvidence(_handle CGoHandle, claimID *C.char, evidencePath *C.char) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).AddEvidence(C.GoString(claimID), C.GoString(evidencePath))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

//export service_ClaimManager_GetClaim
func service_ClaimManager_GetClaim(_handle CGoHandle, claimID *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaim(C.GoString(claimID))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Ptr_model_Claim(cret)
}

//export service_ClaimManager_GetClaimsByService
func service_ClaimManager_GetClaimsByService(_handle CGoHandle, svc *C.char, approved C.char, includeRejected C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaimsByService(C.GoString(svc), boolPyToGo(approved), boolPyToGo(includeRejected))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Slice_Ptr_model_Claim(&cret)
}

//export service_ClaimManager_GetClaimsByCase
func service_ClaimManager_GetClaimsByCase(_handle CGoHandle, caseID CGoHandle, approved C.char, includeRejected C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaimsByCase(deptrFromHandle_uuid_UUID(caseID), boolPyToGo(approved), boolPyToGo(includeRejected))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Slice_Ptr_model_Claim(&cret)
}

//export service_ClaimManager_GetClaimsByClaimant
func service_ClaimManager_GetClaimsByClaimant(_handle CGoHandle, claimant *C.char, approved C.char, includeRejected C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaimsByClaimant(C.GoString(claimant), boolPyToGo(approved), boolPyToGo(includeRejected))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Slice_Ptr_model_Claim(&cret)
}

//export service_ClaimManager_GetClaimsByBSN
func service_ClaimManager_GetClaimsByBSN(_handle CGoHandle, bsn *C.char, approved C.char, includeRejected C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaimsByBSN(C.GoString(bsn), boolPyToGo(approved), boolPyToGo(includeRejected))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Slice_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Slice_Ptr_model_Claim(&cret)
}

//export service_ClaimManager_GetClaimByBSNServiceLaw
func service_ClaimManager_GetClaimByBSNServiceLaw(_handle CGoHandle, bsn *C.char, svc *C.char, law *C.char, approved C.char, includeRejected C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.ClaimManager")
	if __err != nil {
		return handleFromPtr_Map_string_Ptr_model_Claim(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.ClaimManager{})).(*service.ClaimManager).GetClaimByBSNServiceLaw(C.GoString(bsn), C.GoString(svc), C.GoString(law), boolPyToGo(approved), boolPyToGo(includeRejected))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Map_string_Ptr_model_Claim(nil)
	}
	return handleFromPtr_Map_string_Ptr_model_Claim(&cret)
}

// --- wrapping struct: service.RuleService ---
//
//export service_RuleService_CTor
func service_RuleService_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_service_RuleService(&service.RuleService{}))
}

//export service_RuleService_ServiceName_Get
func service_RuleService_ServiceName_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_service_RuleService(handle)
	return C.CString(op.ServiceName)
}

//export service_RuleService_ServiceName_Set
func service_RuleService_ServiceName_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_service_RuleService(handle)
	op.ServiceName = C.GoString(val)
}

//export service_RuleService_Services_Get
func service_RuleService_Services_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_RuleService(handle)
	return handleFromPtr_Ptr_service_Services(op.Services)
}

//export service_RuleService_Services_Set
func service_RuleService_Services_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_RuleService(handle)
	op.Services = ptrFromHandle_Ptr_service_Services(val)
}

//export service_RuleService_Resolver_Get
func service_RuleService_Resolver_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_RuleService(handle)
	return handleFromPtr_Ptr_utils_RuleResolver(op.Resolver)
}

//export service_RuleService_Resolver_Set
func service_RuleService_Resolver_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_RuleService(handle)
	op.Resolver = ptrFromHandle_Ptr_utils_RuleResolver(val)
}

//export service_RuleService_SourceDataFrames_Get
func service_RuleService_SourceDataFrames_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_RuleService(handle)
	return handleFromPtr_Map_string_model_DataFrame(&op.SourceDataFrames)
}

//export service_RuleService_SourceDataFrames_Set
func service_RuleService_SourceDataFrames_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_RuleService(handle)
	op.SourceDataFrames = deptrFromHandle_Map_string_model_DataFrame(val)
}

//export service_RuleService_GetResolver
func service_RuleService_GetResolver(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.RuleService")
	if __err != nil {
		return handleFromPtr_Ptr_utils_RuleResolver(nil)
	}
	return handleFromPtr_Ptr_utils_RuleResolver(gopyh.Embed(vifc, reflect.TypeOf(service.RuleService{})).(*service.RuleService).GetResolver())

}

//export service_RuleService_Evaluate
func service_RuleService_Evaluate(_handle CGoHandle, ctx CGoHandle, law *C.char, referenceDate *C.char, parameters CGoHandle, overwriteInput CGoHandle, requestedOutput *C.char, approved C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.RuleService")
	if __err != nil {
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.RuleService{})).(*service.RuleService).Evaluate(ptrFromHandle_context_Context(ctx), C.GoString(law), C.GoString(referenceDate), deptrFromHandle_Map_string_any(parameters), deptrFromHandle_Map_string_Map_string_any(overwriteInput), C.GoString(requestedOutput), boolPyToGo(approved))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	return handleFromPtr_Ptr_model_RuleResult(cret)
}

//export service_RuleService_GetRuleInfo
func service_RuleService_GetRuleInfo(_handle CGoHandle, law *C.char, referenceDate *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.RuleService")
	if __err != nil {
		return handleFromPtr_Map_string_any(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.RuleService{})).(*service.RuleService).GetRuleInfo(C.GoString(law), C.GoString(referenceDate))

	return handleFromPtr_Map_string_any(&cret)
}

//export service_RuleService_SetSourceDataFrame
func service_RuleService_SetSourceDataFrame(_handle CGoHandle, table *C.char, df CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.RuleService")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(service.RuleService{})).(*service.RuleService).SetSourceDataFrame(C.GoString(table), ptrFromHandle_model_DataFrame(df))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(service.RuleService{})).(*service.RuleService).SetSourceDataFrame(C.GoString(table), ptrFromHandle_model_DataFrame(df))
	}
}

// --- wrapping struct: service.Services ---
//
//export service_Services_CTor
func service_Services_CTor() CGoHandle {
	return CGoHandle(handleFromPtr_service_Services(&service.Services{}))
}

//export service_Services_Resolver_Get
func service_Services_Resolver_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_Services(handle)
	return handleFromPtr_Ptr_utils_RuleResolver(op.Resolver)
}

//export service_Services_Resolver_Set
func service_Services_Resolver_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_Services(handle)
	op.Resolver = ptrFromHandle_Ptr_utils_RuleResolver(val)
}

//export service_Services_RootReferenceDate_Get
func service_Services_RootReferenceDate_Get(handle CGoHandle) *C.char {
	op := ptrFromHandle_service_Services(handle)
	return C.CString(op.RootReferenceDate)
}

//export service_Services_RootReferenceDate_Set
func service_Services_RootReferenceDate_Set(handle CGoHandle, val *C.char) {
	op := ptrFromHandle_service_Services(handle)
	op.RootReferenceDate = C.GoString(val)
}

//export service_Services_CaseManager_Get
func service_Services_CaseManager_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_Services(handle)
	return handleFromPtr_Ptr_service_CaseManager(op.CaseManager)
}

//export service_Services_CaseManager_Set
func service_Services_CaseManager_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_Services(handle)
	op.CaseManager = ptrFromHandle_Ptr_service_CaseManager(val)
}

//export service_Services_ClaimManager_Get
func service_Services_ClaimManager_Get(handle CGoHandle) CGoHandle {
	op := ptrFromHandle_service_Services(handle)
	return handleFromPtr_Ptr_service_ClaimManager(op.ClaimManager)
}

//export service_Services_ClaimManager_Set
func service_Services_ClaimManager_Set(handle CGoHandle, val CGoHandle) {
	op := ptrFromHandle_service_Services(handle)
	op.ClaimManager = ptrFromHandle_Ptr_service_ClaimManager(val)
}

//export service_Services_GetDiscoverableServiceLaws
func service_Services_GetDiscoverableServiceLaws(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_Map_string_Slice_string(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).GetDiscoverableServiceLaws()

	return handleFromPtr_Map_string_Slice_string(&cret)
}

//export service_Services_SetSourceDataFrame
func service_Services_SetSourceDataFrame(_handle CGoHandle, svc *C.char, table *C.char, df CGoHandle, goRun C.char) {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return
	}
	if boolPyToGo(goRun) {
		go gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).SetSourceDataFrame(C.GoString(svc), C.GoString(table), ptrFromHandle_model_DataFrame(df))
	} else {
		gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).SetSourceDataFrame(C.GoString(svc), C.GoString(table), ptrFromHandle_model_DataFrame(df))
	}
}

//export service_Services_GetResolver
func service_Services_GetResolver(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_Ptr_utils_RuleResolver(nil)
	}
	return handleFromPtr_Ptr_utils_RuleResolver(gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).GetResolver())

}

//export service_Services_GetCaseManager
func service_Services_GetCaseManager(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_s1_context_CaseManagerAccessor(nil)
	}
	return handleFromPtr_s1_context_CaseManagerAccessor(gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).GetCaseManager())

}

//export service_Services_GetClaimManager
func service_Services_GetClaimManager(_handle CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_s1_context_ClaimManagerAccessor(nil)
	}
	return handleFromPtr_s1_context_ClaimManagerAccessor(gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).GetClaimManager())

}

//export service_Services_EvaluateWithCtx
func service_Services_EvaluateWithCtx(_handle CGoHandle, svc *C.char, law *C.char, parameters CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).EvaluateWithCtx(C.GoString(svc), C.GoString(law), deptrFromHandle_Map_string_any(parameters))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	return handleFromPtr_Ptr_model_RuleResult(cret)
}

//export service_Services_Evaluate
func service_Services_Evaluate(_handle CGoHandle, ctx CGoHandle, svc *C.char, law *C.char, parameters CGoHandle, referenceDate *C.char, overwriteInput CGoHandle, requestedOutput *C.char, approved C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	cret, __err := gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).Evaluate(ptrFromHandle_context_Context(ctx), C.GoString(svc), C.GoString(law), deptrFromHandle_Map_string_any(parameters), C.GoString(referenceDate), deptrFromHandle_Map_string_Map_string_any(overwriteInput), C.GoString(requestedOutput), boolPyToGo(approved))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		C.free(unsafe.Pointer(estr))
		return handleFromPtr_Ptr_model_RuleResult(nil)
	}
	return handleFromPtr_Ptr_model_RuleResult(cret)
}

//export service_Services_ExtractValueTree
func service_Services_ExtractValueTree(_handle CGoHandle, root CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return handleFromPtr_Map_string_any(nil)
	}
	cret := gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).ExtractValueTree(ptrFromHandle_Ptr_model_PathNode(root))

	return handleFromPtr_Map_string_any(&cret)
}

//export service_Services_ApplyRules
func service_Services_ApplyRules(_handle CGoHandle, ctx CGoHandle, event CGoHandle) *C.char {
	_saved_thread := C.PyEval_SaveThread()
	vifc, __err := gopyh.VarFromHandleTry((gopyh.CGoHandle)(_handle), "*service.Services")
	if __err != nil {
		return errorGoToPy(nil)
	}
	__err = gopyh.Embed(vifc, reflect.TypeOf(service.Services{})).(*service.Services).ApplyRules(ptrFromHandle_context_Context(ctx), ptrFromHandle_Ptr_model_Event(event))

	C.PyEval_RestoreThread(_saved_thread)
	if __err != nil {
		estr := C.CString(__err.Error())
		C.PyErr_SetString(C.PyExc_RuntimeError, estr)
		return estr
	}
	return C.CString("")
}

// ---- Slices ---

// ---- Maps ---

// ---- Constructors ---

//export service_NewCaseManager
func service_NewCaseManager(logger CGoHandle, services CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_service_CaseManager(service.NewCaseManager(ptrFromHandle_logging_Logger(logger), ptrFromHandle_Ptr_service_Services(services)))

}

//export service_NewClaimManager
func service_NewClaimManager(services CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_service_ClaimManager(service.NewClaimManager(ptrFromHandle_Ptr_service_Services(services)))

}

//export service_NewRuleService
func service_NewRuleService(logger CGoHandle, serviceName *C.char, services CGoHandle) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_service_RuleService(service.NewRuleService(ptrFromHandle_logging_Logger(logger), C.GoString(serviceName), ptrFromHandle_Ptr_service_Services(services)))

}

//export service_NewServices
func service_NewServices(referenceDate *C.char) CGoHandle {
	_saved_thread := C.PyEval_SaveThread()
	defer C.PyEval_RestoreThread(_saved_thread)
	return handleFromPtr_Ptr_service_Services(service.NewServices(C.GoString(referenceDate)))

}

// ---- Functions ---
