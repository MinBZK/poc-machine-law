# python wrapper for package github.com/minbzk/poc-machine-law/machinev2/service within overall package gopy_machine
# This is what you import to use the package.
# File is generated by gopy. Do not edit.
# gopy build -vm=python3 -output=gopy_machine/tmp -name=gopy_machine github.com/minbzk/poc-machine-law/machinev2/service

# the following is required to enable dlopen to open the _go.so file
import os, sys, inspect, collections

try:
    import collections.abc as _collections_abc
except ImportError:
    _collections_abc = collections

cwd = os.getcwd()
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
os.chdir(currentdir)
from . import _gopy_machine
from . import go

os.chdir(cwd)

# to use this code in your end-user python file, import it as follows:
# from gopy_machine import service
# and then refer to everything using service. prefix
# packages imported by this package listed below:


# ---- Types ---


# Python type for slice []*casemanager.Case
class Slice_Ptr_casemanager_Case(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Ptr_casemanager_Case_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Ptr_casemanager_Case.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Ptr_casemanager_Case len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Ptr_casemanager_Case([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Ptr_casemanager_Case_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Ptr_casemanager_Case_len(self.handle)
                return Slice_Ptr_casemanager_Case(
                    handle=_gopy_machine.Slice_Ptr_casemanager_Case_subslice(self.handle, st, ed)
                )
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return go.Ptr_casemanager_Case(handle=_gopy_machine.Slice_Ptr_casemanager_Case_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Ptr_casemanager_Case_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Ptr_casemanager_Case.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = go.Ptr_casemanager_Case(handle=_gopy_machine.Slice_Ptr_casemanager_Case_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Ptr_casemanager_Case_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for slice []*model.Claim
class Slice_Ptr_model_Claim(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Ptr_model_Claim_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Ptr_model_Claim.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Ptr_model_Claim len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Ptr_model_Claim([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Ptr_model_Claim_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Ptr_model_Claim_len(self.handle)
                return Slice_Ptr_model_Claim(handle=_gopy_machine.Slice_Ptr_model_Claim_subslice(self.handle, st, ed))
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return go.Ptr_model_Claim(handle=_gopy_machine.Slice_Ptr_model_Claim_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Ptr_model_Claim_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Ptr_model_Claim.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = go.Ptr_model_Claim(handle=_gopy_machine.Slice_Ptr_model_Claim_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Ptr_model_Claim_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for slice []*model.Event
class Slice_Ptr_model_Event(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Ptr_model_Event_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Ptr_model_Event.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Ptr_model_Event len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Ptr_model_Event([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Ptr_model_Event_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Ptr_model_Event_len(self.handle)
                return Slice_Ptr_model_Event(handle=_gopy_machine.Slice_Ptr_model_Event_subslice(self.handle, st, ed))
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return go.Ptr_model_Event(handle=_gopy_machine.Slice_Ptr_model_Event_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Ptr_model_Event_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Ptr_model_Event.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = go.Ptr_model_Event(handle=_gopy_machine.Slice_Ptr_model_Event_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Ptr_model_Event_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for slice []*model.PathNode
class Slice_Ptr_model_PathNode(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Ptr_model_PathNode_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Ptr_model_PathNode.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Ptr_model_PathNode len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Ptr_model_PathNode([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Ptr_model_PathNode_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Ptr_model_PathNode_len(self.handle)
                return Slice_Ptr_model_PathNode(
                    handle=_gopy_machine.Slice_Ptr_model_PathNode_subslice(self.handle, st, ed)
                )
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return go.Ptr_model_PathNode(handle=_gopy_machine.Slice_Ptr_model_PathNode_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Ptr_model_PathNode_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Ptr_model_PathNode.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = go.Ptr_model_PathNode(handle=_gopy_machine.Slice_Ptr_model_PathNode_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Ptr_model_PathNode_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for slice []*utils.RuleSpec
class Slice_Ptr_utils_RuleSpec(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Ptr_utils_RuleSpec_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Ptr_utils_RuleSpec.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Ptr_utils_RuleSpec len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Ptr_utils_RuleSpec([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Ptr_utils_RuleSpec_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Ptr_utils_RuleSpec_len(self.handle)
                return Slice_Ptr_utils_RuleSpec(
                    handle=_gopy_machine.Slice_Ptr_utils_RuleSpec_subslice(self.handle, st, ed)
                )
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return go.Ptr_utils_RuleSpec(handle=_gopy_machine.Slice_Ptr_utils_RuleSpec_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Ptr_utils_RuleSpec_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Ptr_utils_RuleSpec.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = go.Ptr_utils_RuleSpec(handle=_gopy_machine.Slice_Ptr_utils_RuleSpec_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Ptr_utils_RuleSpec_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for slice []map[string]any
class Slice_Map_string_any(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Slice_Map_string_any_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Iterable):
                    raise TypeError("Slice_Map_string_any.__init__ takes a sequence as argument")
                for elt in args[0]:
                    self.append(elt)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "service.Slice_Map_string_any len: " + str(len(self)) + " handle: " + str(self.handle) + " ["
        if len(self) < 120:
            s += ", ".join(map(str, self)) + "]"
        return s

    def __repr__(self):
        return "service.Slice_Map_string_any([" + ", ".join(map(str, self)) + "])"

    def __len__(self):
        return _gopy_machine.Slice_Map_string_any_len(self.handle)

    def __getitem__(self, key):
        if isinstance(key, slice):
            if key.step == None or key.step == 1:
                st = key.start
                ed = key.stop
                if st == None:
                    st = 0
                if ed == None:
                    ed = _gopy_machine.Slice_Map_string_any_len(self.handle)
                return Slice_Map_string_any(handle=_gopy_machine.Slice_Map_string_any_subslice(self.handle, st, ed))
            return [self[ii] for ii in range(*key.indices(len(self)))]
        elif isinstance(key, int):
            if key < 0:
                key += len(self)
            if key < 0 or key >= len(self):
                raise IndexError("slice index out of range")
            return Map_string_any(handle=_gopy_machine.Slice_Map_string_any_elem(self.handle, key))
        else:
            raise TypeError("slice index invalid type")

    def __setitem__(self, idx, value):
        if idx < 0:
            idx += len(self)
        if idx < len(self):
            _gopy_machine.Slice_Map_string_any_set(self.handle, idx, value.handle)
            return
        raise IndexError("slice index out of range")

    def __iadd__(self, value):
        if not isinstance(value, _collections_abc.Iterable):
            raise TypeError("Slice_Map_string_any.__iadd__ takes a sequence as argument")
        for elt in value:
            self.append(elt)
        return self

    def __iter__(self):
        self.index = 0
        return self

    def __next__(self):
        if self.index < len(self):
            rv = Map_string_any(handle=_gopy_machine.Slice_Map_string_any_elem(self.handle, self.index))
            self.index = self.index + 1
            return rv
        raise StopIteration

    def append(self, value):
        _gopy_machine.Slice_Map_string_any_append(self.handle, value.handle)

    def copy(self, src):
        """copy emulates the go copy function, copying elements into this list from source list, up to min of size of each list"""
        mx = min(len(self), len(src))
        for i in range(mx):
            self[i] = src[i]


# Python type for map map[string]*model.Claim
class Map_string_Ptr_model_Claim(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Map_string_Ptr_model_Claim_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Mapping):
                    raise TypeError("Map_string_Ptr_model_Claim.__init__ takes a mapping as argument")
                for k, v in args[0].items():
                    _gopy_machine.Map_string_Ptr_model_Claim_set(self.handle, k, v)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "gopy_machine.Map_string_Ptr_model_Claim len: " + str(len(self)) + " handle: " + str(self.handle) + " {"
        if len(self) < 120:
            for k, v in self.items():
                s += str(k) + "=" + str(v) + ", "
        return s + "}"

    def __repr__(self):
        s = "gopy_machine.Map_string_Ptr_model_Claim({"
        for k, v in self.items():
            s += str(k) + "=" + str(v) + ", "
        return s + "})"

    def __len__(self):
        return _gopy_machine.Map_string_Ptr_model_Claim_len(self.handle)

    def __getitem__(self, key):
        return go.Ptr_model_Claim(handle=_gopy_machine.Map_string_Ptr_model_Claim_elem(self.handle, key))

    def __setitem__(self, key, value):
        _gopy_machine.Map_string_Ptr_model_Claim_set(self.handle, key, value.handle)

    def __delitem__(self, key):
        return _gopy_machine.Map_string_Ptr_model_Claim_delete(self.handle, key)

    def keys(self):
        return go.Slice_string(handle=_gopy_machine.Map_string_Ptr_model_Claim_keys(self.handle))

    def values(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append(self[k])
        return vls

    def items(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append((k, self[k]))
        return vls

    def __iter__(self):
        return iter(self.items())

    def __contains__(self, key):
        return _gopy_machine.Map_string_Ptr_model_Claim_contains(self.handle, key)


# Python type for map map[string][]string
class Map_string_Slice_string(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Map_string_Slice_string_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Mapping):
                    raise TypeError("Map_string_Slice_string.__init__ takes a mapping as argument")
                for k, v in args[0].items():
                    _gopy_machine.Map_string_Slice_string_set(self.handle, k, v)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "gopy_machine.Map_string_Slice_string len: " + str(len(self)) + " handle: " + str(self.handle) + " {"
        if len(self) < 120:
            for k, v in self.items():
                s += str(k) + "=" + str(v) + ", "
        return s + "}"

    def __repr__(self):
        s = "gopy_machine.Map_string_Slice_string({"
        for k, v in self.items():
            s += str(k) + "=" + str(v) + ", "
        return s + "})"

    def __len__(self):
        return _gopy_machine.Map_string_Slice_string_len(self.handle)

    def __getitem__(self, key):
        return go.Slice_string(handle=_gopy_machine.Map_string_Slice_string_elem(self.handle, key))

    def __setitem__(self, key, value):
        _gopy_machine.Map_string_Slice_string_set(self.handle, key, value.handle)

    def __delitem__(self, key):
        return _gopy_machine.Map_string_Slice_string_delete(self.handle, key)

    def keys(self):
        return go.Slice_string(handle=_gopy_machine.Map_string_Slice_string_keys(self.handle))

    def values(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append(self[k])
        return vls

    def items(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append((k, self[k]))
        return vls

    def __iter__(self):
        return iter(self.items())

    def __contains__(self, key):
        return _gopy_machine.Map_string_Slice_string_contains(self.handle, key)


# Python type for map map[string]any
class Map_string_any(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Map_string_any_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Mapping):
                    raise TypeError("Map_string_any.__init__ takes a mapping as argument")
                for k, v in args[0].items():
                    _gopy_machine.Map_string_any_set(self.handle, k, v)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "gopy_machine.Map_string_any len: " + str(len(self)) + " handle: " + str(self.handle) + " {"
        if len(self) < 120:
            for k, v in self.items():
                s += str(k) + "=" + str(v) + ", "
        return s + "}"

    def __repr__(self):
        s = "gopy_machine.Map_string_any({"
        for k, v in self.items():
            s += str(k) + "=" + str(v) + ", "
        return s + "})"

    def __len__(self):
        return _gopy_machine.Map_string_any_len(self.handle)

    def __getitem__(self, key):
        return any(handle=_gopy_machine.Map_string_any_elem(self.handle, key))

    def __setitem__(self, key, value):
        _gopy_machine.Map_string_any_set(self.handle, key, value.handle)

    def __delitem__(self, key):
        return _gopy_machine.Map_string_any_delete(self.handle, key)

    def keys(self):
        return go.Slice_string(handle=_gopy_machine.Map_string_any_keys(self.handle))

    def values(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append(self[k])
        return vls

    def items(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append((k, self[k]))
        return vls

    def __iter__(self):
        return iter(self.items())

    def __contains__(self, key):
        return _gopy_machine.Map_string_any_contains(self.handle, key)


# Python type for map map[string]model.DataFrame
class Map_string_model_DataFrame(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Map_string_model_DataFrame_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Mapping):
                    raise TypeError("Map_string_model_DataFrame.__init__ takes a mapping as argument")
                for k, v in args[0].items():
                    _gopy_machine.Map_string_model_DataFrame_set(self.handle, k, v)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "gopy_machine.Map_string_model_DataFrame len: " + str(len(self)) + " handle: " + str(self.handle) + " {"
        if len(self) < 120:
            for k, v in self.items():
                s += str(k) + "=" + str(v) + ", "
        return s + "}"

    def __repr__(self):
        s = "gopy_machine.Map_string_model_DataFrame({"
        for k, v in self.items():
            s += str(k) + "=" + str(v) + ", "
        return s + "})"

    def __len__(self):
        return _gopy_machine.Map_string_model_DataFrame_len(self.handle)

    def __getitem__(self, key):
        return go.model_DataFrame(handle=_gopy_machine.Map_string_model_DataFrame_elem(self.handle, key))

    def __setitem__(self, key, value):
        _gopy_machine.Map_string_model_DataFrame_set(self.handle, key, value.handle)

    def __delitem__(self, key):
        return _gopy_machine.Map_string_model_DataFrame_delete(self.handle, key)

    def keys(self):
        return go.Slice_string(handle=_gopy_machine.Map_string_model_DataFrame_keys(self.handle))

    def values(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append(self[k])
        return vls

    def items(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append((k, self[k]))
        return vls

    def __iter__(self):
        return iter(self.items())

    def __contains__(self, key):
        return _gopy_machine.Map_string_model_DataFrame_contains(self.handle, key)


# Python type for map map[string]map[string]any
class Map_string_Map_string_any(go.GoClass):
    """"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameter is a python list that we copy from
        """
        self.index = 0
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.Map_string_Map_string_any_CTor()
            _gopy_machine.IncRef(self.handle)
            if len(args) > 0:
                if not isinstance(args[0], _collections_abc.Mapping):
                    raise TypeError("Map_string_Map_string_any.__init__ takes a mapping as argument")
                for k, v in args[0].items():
                    _gopy_machine.Map_string_Map_string_any_set(self.handle, k, v)

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        s = "gopy_machine.Map_string_Map_string_any len: " + str(len(self)) + " handle: " + str(self.handle) + " {"
        if len(self) < 120:
            for k, v in self.items():
                s += str(k) + "=" + str(v) + ", "
        return s + "}"

    def __repr__(self):
        s = "gopy_machine.Map_string_Map_string_any({"
        for k, v in self.items():
            s += str(k) + "=" + str(v) + ", "
        return s + "})"

    def __len__(self):
        return _gopy_machine.Map_string_Map_string_any_len(self.handle)

    def __getitem__(self, key):
        return Map_string_any(handle=_gopy_machine.Map_string_Map_string_any_elem(self.handle, key))

    def __setitem__(self, key, value):
        _gopy_machine.Map_string_Map_string_any_set(self.handle, key, value.handle)

    def __delitem__(self, key):
        return _gopy_machine.Map_string_Map_string_any_delete(self.handle, key)

    def keys(self):
        return go.Slice_string(handle=_gopy_machine.Map_string_Map_string_any_keys(self.handle))

    def values(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append(self[k])
        return vls

    def items(self):
        vls = []
        kys = self.keys()
        for k in kys:
            vls.append((k, self[k]))
        return vls

    def __iter__(self):
        return iter(self.items())

    def __contains__(self, key):
        return _gopy_machine.Map_string_Map_string_any_contains(self.handle, key)


# ---- Enums from Go (collections of consts with same type) ---


# ---- Constants from Go: Python can only ask that you please don't change these! ---


# ---- Global Variables: can only use functions to access ---


# ---- Interfaces ---


# ---- Structs ---


# Python type for struct service.CaseManager
class CaseManager(go.GoClass):
    """CaseManager manages service cases using the EventHorizon-based casemanager.\n"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.service_CaseManager_CTor()
            _gopy_machine.IncRef(self.handle)
            if 1 < len(args):
                self.Services = args[1]
            if "Services" in kwargs:
                self.Services = kwargs["Services"]
            if 4 < len(args):
                self.SampleRate = args[4]
            if "SampleRate" in kwargs:
                self.SampleRate = kwargs["SampleRate"]

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.CaseManager{"
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ", "
            sv += v[0] + "=" + str(v[1])
        return sv + "}"

    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.CaseManager ( "
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + "=" + str(v[1]) + ", "
        return sv + ")"

    @property
    def Services(self):
        return Services(handle=_gopy_machine.service_CaseManager_Services_Get(self.handle))

    @Services.setter
    def Services(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_CaseManager_Services_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def SampleRate(self):
        return _gopy_machine.service_CaseManager_SampleRate_Get(self.handle)

    @SampleRate.setter
    def SampleRate(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_CaseManager_SampleRate_Set(self.handle, value.handle)
        else:
            _gopy_machine.service_CaseManager_SampleRate_Set(self.handle, value)

    def SetCase(self, caseID, key, goRun=False):
        """SetCase([]int caseID, str key)"""
        _gopy_machine.service_CaseManager_SetCase(self.handle, caseID.handle, key, goRun)

    def SubmitCase(self, ctx, bsn, serviceType, law, parameters, claimedResult, approvedClaimsOnly):
        """SubmitCase(object ctx, str bsn, str serviceType, str law, object parameters, object claimedResult, bool approvedClaimsOnly) []int, str

        SubmitCase submits a new case and automatically processes it
        """
        return go.uuid_UUID(
            handle=_gopy_machine.service_CaseManager_SubmitCase(
                self.handle,
                ctx.handle,
                bsn,
                serviceType,
                law,
                parameters.handle,
                claimedResult.handle,
                approvedClaimsOnly,
            )
        )

    def CompleteManualReview(self, ctx, caseID, verifierID, approved, reason, overrideResult):
        """CompleteManualReview(object ctx, []int caseID, str verifierID, bool approved, str reason, object overrideResult) str

        CompleteManualReview completes manual review of a case
        """
        return _gopy_machine.service_CaseManager_CompleteManualReview(
            self.handle, ctx.handle, caseID.handle, verifierID, approved, reason, overrideResult.handle
        )

    def ObjectCase(self, ctx, caseID, reason):
        """ObjectCase(object ctx, []int caseID, str reason) str

        ObjectCase submits an objection for a case
        """
        return _gopy_machine.service_CaseManager_ObjectCase(self.handle, ctx.handle, caseID.handle, reason)

    def CanAppeal(self, caseID):
        """CanAppeal([]int caseID) bool, str

        CanAppeal checks if appeal is possible for a case
        """
        return _gopy_machine.service_CaseManager_CanAppeal(self.handle, caseID.handle)

    def CanObject(self, caseID):
        """CanObject([]int caseID) bool, str

        CanObject checks if objection is possible for a case
        """
        return _gopy_machine.service_CaseManager_CanObject(self.handle, caseID.handle)

    def GetCase(self, bsn, serviceType, law):
        """GetCase(str bsn, str serviceType, str law) object

        GetCase gets a case for a specific bsn, service and law combination
        """
        return go.Ptr_casemanager_Case(
            handle=_gopy_machine.service_CaseManager_GetCase(self.handle, bsn, serviceType, law)
        )

    def GetCaseByID(self, ctx, id):
        """GetCaseByID(object ctx, []int id) object, str

        GetCaseByID gets a case by ID
        """
        return go.Ptr_casemanager_Case(
            handle=_gopy_machine.service_CaseManager_GetCaseByID(self.handle, ctx.handle, id.handle)
        )

    def GetCasesByStatus(self, serviceType, status):
        """GetCasesByStatus(str serviceType, str status) []object

        GetCasesByStatus gets all cases for a service in a particular status
        """
        return Slice_Ptr_casemanager_Case(
            handle=_gopy_machine.service_CaseManager_GetCasesByStatus(self.handle, serviceType, status)
        )

    def GetCasesByLaw(self, law, serviceType):
        """GetCasesByLaw(str law, str serviceType) []object

        GetCasesByLaw gets all cases for a specific law and service combination
        """
        return Slice_Ptr_casemanager_Case(
            handle=_gopy_machine.service_CaseManager_GetCasesByLaw(self.handle, law, serviceType)
        )

    def GetEventsByUUID(self, caseID):
        """GetEventsByUUID([]int caseID) []object

        GetEventsByUUID gets events, optionally filtered by case ID
        """
        return Slice_Ptr_model_Event(
            handle=_gopy_machine.service_CaseManager_GetEventsByUUID(self.handle, caseID.handle)
        )

    def GetEvents(self, caseID):
        """GetEvents(object caseID) []object

        GetEvents implements the CaseManagerAccessor interface
        Converts internal event model to map format for use by dataframe
        """
        return Slice_Map_string_any(handle=_gopy_machine.service_CaseManager_GetEvents(self.handle, caseID.handle))

    def Save(self, ctx, c):
        """Save(object ctx, object c) str"""
        return _gopy_machine.service_CaseManager_Save(self.handle, ctx.handle, c.handle)

    def Wait(self, goRun=False):
        """Wait()"""
        _gopy_machine.service_CaseManager_Wait(self.handle, goRun)

    def Close(self, goRun=False):
        """Close()"""
        _gopy_machine.service_CaseManager_Close(self.handle, goRun)


# Python type for struct service.ClaimManager
class ClaimManager(go.GoClass):
    """ClaimManager manages claims against services\n"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.service_ClaimManager_CTor()
            _gopy_machine.IncRef(self.handle)
            if 0 < len(args):
                self.Services = args[0]
            if "Services" in kwargs:
                self.Services = kwargs["Services"]
            if 1 < len(args):
                self.CaseManager = args[1]
            if "CaseManager" in kwargs:
                self.CaseManager = kwargs["CaseManager"]

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.ClaimManager{"
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ", "
            sv += v[0] + "=" + str(v[1])
        return sv + "}"

    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.ClaimManager ( "
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + "=" + str(v[1]) + ", "
        return sv + ")"

    @property
    def Services(self):
        return Services(handle=_gopy_machine.service_ClaimManager_Services_Get(self.handle))

    @Services.setter
    def Services(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_ClaimManager_Services_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def CaseManager(self):
        return CaseManager(handle=_gopy_machine.service_ClaimManager_CaseManager_Get(self.handle))

    @CaseManager.setter
    def CaseManager(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_ClaimManager_CaseManager_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    def SubmitClaim(
        self, ctx, svc, key, newValue, reason, claimant, law, bsn, caseID, oldValue, evidencePath, autoApprove
    ):
        """SubmitClaim(object ctx, str svc, str key, object newValue, str reason, str claimant, str law, str bsn, []int caseID, object oldValue, str evidencePath, bool autoApprove) str, str

        SubmitClaim submits a new claim
        """
        return _gopy_machine.service_ClaimManager_SubmitClaim(
            self.handle,
            ctx.handle,
            svc,
            key,
            newValue.handle,
            reason,
            claimant,
            law,
            bsn,
            caseID.handle,
            oldValue.handle,
            evidencePath,
            autoApprove,
        )

    def ApproveClaim(self, ctx, claimID, verifiedBy, verifiedValue):
        """ApproveClaim(object ctx, str claimID, str verifiedBy, object verifiedValue) str

        ApproveClaim approves a claim with verified value
        """
        return _gopy_machine.service_ClaimManager_ApproveClaim(
            self.handle, ctx.handle, claimID, verifiedBy, verifiedValue.handle
        )

    def RejectClaim(self, ctx, claimID, rejectedBy, rejectionReason):
        """RejectClaim(object ctx, str claimID, str rejectedBy, str rejectionReason) str

        RejectClaim rejects a claim with reason
        """
        return _gopy_machine.service_ClaimManager_RejectClaim(
            self.handle, ctx.handle, claimID, rejectedBy, rejectionReason
        )

    def LinkCase(self, claimID, caseID):
        """LinkCase(str claimID, []int caseID) str

        LinkCase links an existing claim to a case
        """
        return _gopy_machine.service_ClaimManager_LinkCase(self.handle, claimID, caseID.handle)

    def AddEvidence(self, claimID, evidencePath):
        """AddEvidence(str claimID, str evidencePath) str

        AddEvidence adds evidence to an existing claim
        """
        return _gopy_machine.service_ClaimManager_AddEvidence(self.handle, claimID, evidencePath)

    def GetClaim(self, claimID):
        """GetClaim(str claimID) object, str

        GetClaim gets a claim by ID
        """
        return go.Ptr_model_Claim(handle=_gopy_machine.service_ClaimManager_GetClaim(self.handle, claimID))

    def GetClaimsByService(self, svc, approved, includeRejected):
        """GetClaimsByService(str svc, bool approved, bool includeRejected) []object, str

        GetClaimsByService gets all claims for a service
        """
        return Slice_Ptr_model_Claim(
            handle=_gopy_machine.service_ClaimManager_GetClaimsByService(self.handle, svc, approved, includeRejected)
        )

    def GetClaimsByCase(self, caseID, approved, includeRejected):
        """GetClaimsByCase([]int caseID, bool approved, bool includeRejected) []object, str

        GetClaimsByCase gets all claims for a case
        """
        return Slice_Ptr_model_Claim(
            handle=_gopy_machine.service_ClaimManager_GetClaimsByCase(
                self.handle, caseID.handle, approved, includeRejected
            )
        )

    def GetClaimsByClaimant(self, claimant, approved, includeRejected):
        """GetClaimsByClaimant(str claimant, bool approved, bool includeRejected) []object, str

        GetClaimsByClaimant gets all claims by a claimant
        """
        return Slice_Ptr_model_Claim(
            handle=_gopy_machine.service_ClaimManager_GetClaimsByClaimant(
                self.handle, claimant, approved, includeRejected
            )
        )

    def GetClaimsByBSN(self, bsn, approved, includeRejected):
        """GetClaimsByBSN(str bsn, bool approved, bool includeRejected) []object, str

        GetClaimsByBSN gets all claims for a BSN
        """
        return Slice_Ptr_model_Claim(
            handle=_gopy_machine.service_ClaimManager_GetClaimsByBSN(self.handle, bsn, approved, includeRejected)
        )

    def GetClaimByBSNServiceLaw(self, bsn, svc, law, approved, includeRejected):
        """GetClaimByBSNServiceLaw(str bsn, str svc, str law, bool approved, bool includeRejected) object, str

        GetClaimByBSNServiceLaw gets claims for a BSN, service, and law combination
        """
        return Map_string_Ptr_model_Claim(
            handle=_gopy_machine.service_ClaimManager_GetClaimByBSNServiceLaw(
                self.handle, bsn, svc, law, approved, includeRejected
            )
        )


# Python type for struct service.RuleService
class RuleService(go.GoClass):
    """RuleService interface for executing business rules for a specific service\n"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.service_RuleService_CTor()
            _gopy_machine.IncRef(self.handle)
            if 1 < len(args):
                self.ServiceName = args[1]
            if "ServiceName" in kwargs:
                self.ServiceName = kwargs["ServiceName"]
            if 2 < len(args):
                self.Services = args[2]
            if "Services" in kwargs:
                self.Services = kwargs["Services"]
            if 3 < len(args):
                self.Resolver = args[3]
            if "Resolver" in kwargs:
                self.Resolver = kwargs["Resolver"]
            if 5 < len(args):
                self.SourceDataFrames = args[5]
            if "SourceDataFrames" in kwargs:
                self.SourceDataFrames = kwargs["SourceDataFrames"]

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.RuleService{"
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ", "
            sv += v[0] + "=" + str(v[1])
        return sv + "}"

    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.RuleService ( "
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + "=" + str(v[1]) + ", "
        return sv + ")"

    @property
    def ServiceName(self):
        return _gopy_machine.service_RuleService_ServiceName_Get(self.handle)

    @ServiceName.setter
    def ServiceName(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_RuleService_ServiceName_Set(self.handle, value.handle)
        else:
            _gopy_machine.service_RuleService_ServiceName_Set(self.handle, value)

    @property
    def Services(self):
        return Services(handle=_gopy_machine.service_RuleService_Services_Get(self.handle))

    @Services.setter
    def Services(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_RuleService_Services_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def Resolver(self):
        return go.Ptr_utils_RuleResolver(handle=_gopy_machine.service_RuleService_Resolver_Get(self.handle))

    @Resolver.setter
    def Resolver(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_RuleService_Resolver_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def SourceDataFrames(self):
        return Map_string_model_DataFrame(handle=_gopy_machine.service_RuleService_SourceDataFrames_Get(self.handle))

    @SourceDataFrames.setter
    def SourceDataFrames(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_RuleService_SourceDataFrames_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    def GetResolver(self):
        """GetResolver() object

        GetResolver returns the rule resolver
        """
        return go.Ptr_utils_RuleResolver(handle=_gopy_machine.service_RuleService_GetResolver(self.handle))

    def Evaluate(self, ctx, law, referenceDate, parameters, overwriteInput, requestedOutput, approved):
        """Evaluate(object ctx, str law, str referenceDate, object parameters, object overwriteInput, str requestedOutput, bool approved) object, str

        Evaluate evaluates rules for given law and reference date
        """
        return go.Ptr_model_RuleResult(
            handle=_gopy_machine.service_RuleService_Evaluate(
                self.handle,
                ctx.handle,
                law,
                referenceDate,
                parameters.handle,
                overwriteInput.handle,
                requestedOutput,
                approved,
            )
        )

    def GetRuleInfo(self, law, referenceDate):
        """GetRuleInfo(str law, str referenceDate) object

        GetRuleInfo gets metadata about the rule that would be applied for given law and date
        """
        return Map_string_any(handle=_gopy_machine.service_RuleService_GetRuleInfo(self.handle, law, referenceDate))

    def SetSourceDataFrame(self, table, df, goRun=False):
        """SetSourceDataFrame(str table, object df)

        SetSourceDataFrame sets a source DataFrame
        """
        _gopy_machine.service_RuleService_SetSourceDataFrame(self.handle, table, df.handle, goRun)


# Python type for struct service.Services
class Services(go.GoClass):
    """Services is the main service provider for rule evaluation\n"""

    def __init__(self, *args, **kwargs):
        """
        handle=A Go-side object is always initialized with an explicit handle=arg
        otherwise parameters can be unnamed in order of field names or named fields
        in which case a new Go object is constructed first
        """
        if len(kwargs) == 1 and "handle" in kwargs:
            self.handle = kwargs["handle"]
            _gopy_machine.IncRef(self.handle)
        elif len(args) == 1 and isinstance(args[0], go.GoClass):
            self.handle = args[0].handle
            _gopy_machine.IncRef(self.handle)
        else:
            self.handle = _gopy_machine.service_Services_CTor()
            _gopy_machine.IncRef(self.handle)
            if 1 < len(args):
                self.Resolver = args[1]
            if "Resolver" in kwargs:
                self.Resolver = kwargs["Resolver"]
            if 3 < len(args):
                self.RootReferenceDate = args[3]
            if "RootReferenceDate" in kwargs:
                self.RootReferenceDate = kwargs["RootReferenceDate"]
            if 4 < len(args):
                self.CaseManager = args[4]
            if "CaseManager" in kwargs:
                self.CaseManager = kwargs["CaseManager"]
            if 5 < len(args):
                self.ClaimManager = args[5]
            if "ClaimManager" in kwargs:
                self.ClaimManager = kwargs["ClaimManager"]

    def __del__(self):
        _gopy_machine.DecRef(self.handle)

    def __str__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.Services{"
        first = True
        for v in pr:
            if callable(v[1]):
                continue
            if first:
                first = False
            else:
                sv += ", "
            sv += v[0] + "=" + str(v[1])
        return sv + "}"

    def __repr__(self):
        pr = [(p, getattr(self, p)) for p in dir(self) if not p.startswith("__")]
        sv = "service.Services ( "
        for v in pr:
            if not callable(v[1]):
                sv += v[0] + "=" + str(v[1]) + ", "
        return sv + ")"

    @property
    def Resolver(self):
        return go.Ptr_utils_RuleResolver(handle=_gopy_machine.service_Services_Resolver_Get(self.handle))

    @Resolver.setter
    def Resolver(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_Services_Resolver_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def RootReferenceDate(self):
        return _gopy_machine.service_Services_RootReferenceDate_Get(self.handle)

    @RootReferenceDate.setter
    def RootReferenceDate(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_Services_RootReferenceDate_Set(self.handle, value.handle)
        else:
            _gopy_machine.service_Services_RootReferenceDate_Set(self.handle, value)

    @property
    def CaseManager(self):
        return CaseManager(handle=_gopy_machine.service_Services_CaseManager_Get(self.handle))

    @CaseManager.setter
    def CaseManager(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_Services_CaseManager_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    @property
    def ClaimManager(self):
        return ClaimManager(handle=_gopy_machine.service_Services_ClaimManager_Get(self.handle))

    @ClaimManager.setter
    def ClaimManager(self, value):
        if isinstance(value, go.GoClass):
            _gopy_machine.service_Services_ClaimManager_Set(self.handle, value.handle)
        else:
            raise TypeError("supplied argument type {t} is not a go.GoClass".format(t=type(value)))

    def GetDiscoverableServiceLaws(self):
        """GetDiscoverableServiceLaws() object

        GetDiscoverableServiceLaws returns discoverable services and laws
        """
        return Map_string_Slice_string(handle=_gopy_machine.service_Services_GetDiscoverableServiceLaws(self.handle))

    def SetSourceDataFrame(self, svc, table, df, goRun=False):
        """SetSourceDataFrame(str svc, str table, object df)

        SetSourceDataFrame sets a source DataFrame for a service
        """
        _gopy_machine.service_Services_SetSourceDataFrame(self.handle, svc, table, df.handle, goRun)

    def GetResolver(self):
        """GetResolver() object

        GetResolver returns the rule resolver
        """
        return go.Ptr_utils_RuleResolver(handle=_gopy_machine.service_Services_GetResolver(self.handle))

    def GetCaseManager(self):
        """GetCaseManager() object

        GetCaseManager returns the case manager with access to events
        """
        return go.s1_context_CaseManagerAccessor(handle=_gopy_machine.service_Services_GetCaseManager(self.handle))

    def GetClaimManager(self):
        """GetClaimManager() object

        GetClaimManager returns the claim manager with access to claims
        """
        return go.s1_context_ClaimManagerAccessor(handle=_gopy_machine.service_Services_GetClaimManager(self.handle))

    def EvaluateWithCtx(self, svc, law, parameters):
        """EvaluateWithCtx(str svc, str law, object parameters) object, str"""
        return go.Ptr_model_RuleResult(
            handle=_gopy_machine.service_Services_EvaluateWithCtx(self.handle, svc, law, parameters.handle)
        )

    def Evaluate(self, ctx, svc, law, parameters, referenceDate, overwriteInput, requestedOutput, approved):
        """Evaluate(object ctx, str svc, str law, object parameters, str referenceDate, object overwriteInput, str requestedOutput, bool approved) object, str

        Evaluate evaluates rules for a specific service, law, and context
        """
        return go.Ptr_model_RuleResult(
            handle=_gopy_machine.service_Services_Evaluate(
                self.handle,
                ctx.handle,
                svc,
                law,
                parameters.handle,
                referenceDate,
                overwriteInput.handle,
                requestedOutput,
                approved,
            )
        )

    def ExtractValueTree(self, root):
        """ExtractValueTree(object root) object

        ExtractValueTree extracts a flattened value tree from a path node
        """
        return Map_string_any(handle=_gopy_machine.service_Services_ExtractValueTree(self.handle, root.handle))

    def ApplyRules(self, ctx, event):
        """ApplyRules(object ctx, object event) str

        ApplyRules applies rules in response to events
        """
        return _gopy_machine.service_Services_ApplyRules(self.handle, ctx.handle, event.handle)


# ---- Slices ---


# ---- Maps ---


# ---- Constructors ---
def NewCaseManager(logger, services):
    """NewCaseManager(object logger, object services) object

    NewCaseManager creates a new case manager with EventHorizon components.
    """
    return CaseManager(handle=_gopy_machine.service_NewCaseManager(logger.handle, services.handle))


def NewClaimManager(services):
    """NewClaimManager(object services) object

    NewClaimManager creates a new claim manager
    """
    return ClaimManager(handle=_gopy_machine.service_NewClaimManager(services.handle))


def NewRuleService(logger, serviceName, services):
    """NewRuleService(object logger, str serviceName, object services) object

    NewRuleService creates a new rule service instance
    """
    return RuleService(handle=_gopy_machine.service_NewRuleService(logger.handle, serviceName, services.handle))


def NewServices(referenceDate):
    """NewServices(str referenceDate) object

    NewServices creates a new services instance
    """
    return Services(handle=_gopy_machine.service_NewServices(referenceDate))


# ---- Functions ---
