// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for CaseStatus.
const (
	DECIDED   CaseStatus = "DECIDED"
	INREVIEW  CaseStatus = "IN_REVIEW"
	OBJECTED  CaseStatus = "OBJECTED"
	SUBMITTED CaseStatus = "SUBMITTED"
)

// Defines values for ClaimStatus.
const (
	APPROVED ClaimStatus = "APPROVED"
	PENDING  ClaimStatus = "PENDING"
	REJECTED ClaimStatus = "REJECTED"
)

// Action defines model for Action.
type Action struct {
	// Combine Combination method
	Combine *string `json:"combine"`

	// Conditions Conditional logic
	Conditions *[]Condition `json:"conditions,omitempty"`

	// Operation Operation to perform
	Operation *string `json:"operation"`

	// Output Action output
	Output string `json:"output"`

	// Subject Subject of the action
	Subject *string `json:"subject"`

	// Unit Unit for the action
	Unit *string `json:"unit"`

	// Value Represents a value in an operation (can be a primitive value or nested action)
	Value *ActionValue `json:"value,omitempty"`

	// Values Represents multiple values or a single value
	Values *ActionValues `json:"values,omitempty"`
}

// ActionRequirement Either a nested requirement or an action
type ActionRequirement struct {
	union json.RawMessage
}

// ActionValue Represents a value in an operation (can be a primitive value or nested action)
type ActionValue struct {
	union json.RawMessage
}

// ActionValue1 defines model for .
type ActionValue1 = interface{}

// ActionValues Represents multiple values or a single value
type ActionValues struct {
	union json.RawMessage
}

// ActionValues0 defines model for .
type ActionValues0 = []ActionValue

// ActionValues1 defines model for .
type ActionValues1 = interface{}

// Apply defines model for Apply.
type Apply struct {
	// Aggregate Aggregate identifier
	Aggregate string `json:"aggregate"`

	// Events Associated events
	Events []ApplyEvent `json:"events"`

	// Name Name of the application rule
	Name string `json:"name"`

	// Update Update rules
	Update []Update `json:"update"`
}

// ApplyEvent defines model for ApplyEvent.
type ApplyEvent struct {
	// Filter Event filter criteria
	Filter map[string]interface{} `json:"filter"`

	// Type Event type
	Type string `json:"type"`
}

// BaseField defines model for BaseField.
type BaseField struct {
	// Description Field description
	Description string `json:"description"`

	// Name Field name
	Name string `json:"name"`

	// Required Whether the field is required
	Required *bool     `json:"required"`
	Temporal *Temporal `json:"temporal,omitempty"`

	// Type Field type
	Type     string    `json:"type"`
	TypeSpec *TypeSpec `json:"type_spec,omitempty"`
}

// Case Case
type Case struct {
	// AppealStatus Parameters to set the objection status
	AppealStatus       *CaseAppealStatus `json:"appealStatus,omitempty"`
	Approved           *bool             `json:"approved,omitempty"`
	ApprovedClaimsOnly bool              `json:"approvedClaimsOnly"`

	// Bsn Burgerservicenummer of a Dutch citizen
	Bsn           Bsn                    `json:"bsn"`
	ClaimedResult map[string]interface{} `json:"claimedResult"`

	// Id Identifier of a case
	Id CaseID `json:"id"`

	// Law Specify the law that needs to be executed
	Law string `json:"law"`

	// ObjectionStatus Parameters to set the objection status
	ObjectionStatus *CaseObjectionStatus   `json:"objectionStatus,omitempty"`
	Parameters      map[string]interface{} `json:"parameters"`

	// RulespecId Identifier of the rulespec
	RulespecId openapi_types.UUID `json:"rulespecId"`

	// Service Specify the service that needs to be executed
	Service        string                 `json:"service"`
	Status         CaseStatus             `json:"status"`
	VerifiedResult map[string]interface{} `json:"verifiedResult"`
}

// CaseStatus defines model for Case.Status.
type CaseStatus string

// CaseAppealStatus Parameters to set the objection status
type CaseAppealStatus struct {
	AppealPeriod       *int    `json:"appealPeriod,omitempty"`
	CompetentCourt     *string `json:"competentCourt,omitempty"`
	CourtType          *string `json:"courtType,omitempty"`
	DirectAppeal       *bool   `json:"directAppeal,omitempty"`
	DirectAppealReason *string `json:"directAppealReason,omitempty"`
	NotPossibleReason  *string `json:"notPossibleReason,omitempty"`
	Possible           *bool   `json:"possible,omitempty"`
}

// CaseList List of all cases
type CaseList = []Case

// CaseObject defines model for CaseObject.
type CaseObject struct {
	// Reason Explanation for the objection
	Reason string `json:"reason"`
}

// CaseObjectionStatus Parameters to set the objection status
type CaseObjectionStatus struct {
	Admissable        *bool   `json:"admissable,omitempty"`
	DecisionPeriod    *int    `json:"decisionPeriod,omitempty"`
	ExtensionPeriod   *int    `json:"extensionPeriod,omitempty"`
	NotPossibleReason *string `json:"notPossibleReason,omitempty"`
	ObjectionPeriod   *int    `json:"objectionPeriod,omitempty"`
	Possible          *bool   `json:"possible,omitempty"`
}

// CaseReview defines model for CaseReview.
type CaseReview struct {
	// Approved Decision outcome - true for approval, false for rejection
	Approved bool `json:"approved"`

	// Reason Explanation for the decision
	Reason string `json:"reason"`

	// VerifierId ID of the verifier making the decision
	VerifierId string `json:"verifierId"`
}

// CaseSubmit Case
type CaseSubmit struct {
	ApprovedClaimsOnly bool `json:"approvedClaimsOnly"`

	// Bsn Burgerservicenummer of a Dutch citizen
	Bsn           Bsn                    `json:"bsn"`
	ClaimedResult map[string]interface{} `json:"claimedResult"`

	// Law Specify the law that needs to be executed
	Law        string                 `json:"law"`
	Parameters map[string]interface{} `json:"parameters"`

	// Service Specify the service that needs to be executed
	Service string `json:"service"`
}

// Claim Claim
type Claim struct {
	// Bsn Burgerservicenummer of a Dutch citizen
	Bsn Bsn `json:"bsn"`

	// CaseId Identifier of a case
	CaseId       *CaseID `json:"caseId,omitempty"`
	Claimant     string  `json:"claimant"`
	EvidencePath *string `json:"evidencePath,omitempty"`

	// Id Identifier of a claim
	Id  ClaimID `json:"id"`
	Key string  `json:"key"`

	// Law Specify the law that needs to be executed
	Law      string      `json:"law"`
	NewValue interface{} `json:"newValue"`
	OldValue interface{} `json:"oldValue,omitempty"`
	Reason   string      `json:"reason"`

	// Service Specify the service that needs to be executed
	Service string      `json:"service"`
	Status  ClaimStatus `json:"status"`
}

// ClaimStatus defines model for Claim.Status.
type ClaimStatus string

// ClaimApprove Approve a claim
type ClaimApprove struct {
	// VerifiedBy User that verified the claim
	VerifiedBy string `json:"verifiedBy"`

	// VerifiedValue Verified value for the claim
	VerifiedValue string `json:"verifiedValue"`
}

// ClaimList List of all claims
type ClaimList = []Claim

// ClaimReject Reject a claim
type ClaimReject struct {
	// RejectedBy User that rejected the claim
	RejectedBy string `json:"rejectedBy"`

	// RejectionReason Reason of the rejection
	RejectionReason string `json:"rejectionReason"`
}

// ClaimSubmit Submit a new claim
type ClaimSubmit struct {
	// AutoApprove Whether to automatically approve the claim
	AutoApprove *bool `json:"autoApprove,omitempty"`

	// Bsn Burgerservicenummer of a Dutch citizen
	Bsn Bsn `json:"bsn"`

	// CaseId Optional identifier of the related case
	CaseId *openapi_types.UUID `json:"caseId"`

	// Claimant Identity of the claimant
	Claimant string `json:"claimant"`

	// EvidencePath Path to evidence supporting the claim
	EvidencePath *string `json:"evidencePath"`

	// Key Key to be claimed
	Key string `json:"key"`

	// Law Legal basis for the claim
	Law      string      `json:"law"`
	NewValue interface{} `json:"newValue"`
	OldValue interface{} `json:"oldValue,omitempty"`

	// Reason Reason for the claim
	Reason string `json:"reason"`

	// Service Service identifier
	Service string `json:"service"`
}

// Condition Conditional logic with test, then, and optional else
type Condition struct {
	// Else Represents a value in an operation (can be a primitive value or nested action)
	Else *ActionValue `json:"else,omitempty"`
	Test *Action      `json:"test,omitempty"`

	// Then Represents a value in an operation (can be a primitive value or nested action)
	Then *ActionValue `json:"then,omitempty"`
}

// DataFrame defines model for DataFrame.
type DataFrame struct {
	// Data Column definitions for the data frame
	Data    []map[string]interface{} `json:"data"`
	Service string                   `json:"service"`
	Table   string                   `json:"table"`
}

// Error The error that occured while processing this request.
type Error struct {
	Message string `json:"message"`
}

// Evaluate Evaluate.
type Evaluate struct {
	// Approved only use approved claims, default to true
	Approved *bool `json:"approved,omitempty"`

	// Date Can be used to overwrite the date used by the service
	Date  *openapi_types.Date                `json:"date,omitempty"`
	Input *map[string]map[string]interface{} `json:"input,omitempty"`

	// Law Specify the law that needs to be executed
	Law string `json:"law"`

	// Output specify a requested output value
	Output     *string                 `json:"output,omitempty"`
	Parameters *map[string]interface{} `json:"parameters,omitempty"`

	// Service Specify the service that needs to be executed
	Service string `json:"service"`
}

// Event Event
type Event struct {
	Data map[string]interface{} `json:"data"`

	// EventType Type of the event
	EventType string    `json:"eventType"`
	Timestamp time.Time `json:"timestamp"`
}

// EventList List of all events
type EventList = []Event

// InputField defines model for InputField.
type InputField struct {
	// Description Field description
	Description string `json:"description"`

	// Name Field name
	Name string `json:"name"`

	// Required Whether the field is required
	Required         *bool            `json:"required"`
	ServiceReference ServiceReference `json:"service_reference"`
	Temporal         *Temporal        `json:"temporal,omitempty"`

	// Type Field type
	Type     string    `json:"type"`
	TypeSpec *TypeSpec `json:"type_spec,omitempty"`
}

// Law Law
type Law struct {
	// DiscoverableBy Who can discover this law
	DiscoverableBy []string `json:"discoverableBy"`

	// Name Name of the law
	Name string `json:"name"`
}

// OutputField defines model for OutputField.
type OutputField struct {
	CitizenRelevance string `json:"citizen_relevance"`

	// Description Field description
	Description string `json:"description"`

	// Name Field name
	Name string `json:"name"`

	// Required Whether the field is required
	Required *bool     `json:"required"`
	Temporal *Temporal `json:"temporal,omitempty"`

	// Type Field type
	Type     string    `json:"type"`
	TypeSpec *TypeSpec `json:"type_spec,omitempty"`
}

// Parameter defines model for Parameter.
type Parameter struct {
	// Name Parameter name
	Name string `json:"name"`

	// Reference Parameter reference
	Reference string `json:"reference"`
}

// ParameterField defines model for ParameterField.
type ParameterField = BaseField

// PathNode path node
type PathNode struct {
	Children    *[]PathNode             `json:"children,omitempty"`
	Details     *map[string]interface{} `json:"details,omitempty"`
	Name        string                  `json:"name"`
	Required    *bool                   `json:"required,omitempty"`
	ResolveType *string                 `json:"resolveType,omitempty"`
	Result      interface{}             `json:"result,omitempty"`
	Type        string                  `json:"type"`
}

// Profile Profile
type Profile struct {
	// Bsn Burgerservicenummer of a Dutch citizen
	Bsn Bsn `json:"bsn"`

	// Description Description of the burger
	Description string `json:"description"`

	// Name Name of the burger
	Name string `json:"name"`

	// Sources All sources for a certain profile
	Sources map[string]Source `json:"sources"`
}

// ProfileList List of all burgers
type ProfileList = []Profile

// Properties defines model for Properties.
type Properties struct {
	// Applies Application rules
	Applies *[]Apply `json:"applies,omitempty"`

	// Definitions Additional definitions
	Definitions *map[string]interface{} `json:"definitions,omitempty"`

	// Input Input fields
	Input *[]InputField `json:"input,omitempty"`

	// Output Output fields
	Output *[]OutputField `json:"output,omitempty"`

	// Parameters Parameter fields
	Parameters *[]ParameterField `json:"parameters,omitempty"`

	// Sources Source fields
	Sources *[]SourceField `json:"sources,omitempty"`
}

// Reference defines model for Reference.
type Reference struct {
	// Article Article reference
	Article string `json:"article"`

	// Law Law reference
	Law string `json:"law"`

	// Url URL to the legal reference
	Url string `json:"url"`
}

// Requirement Logical requirements with AND/OR operations
type Requirement struct {
	// All All requirements must be met (AND logic)
	All *[]ActionRequirement `json:"all"`

	// Or Any requirement must be met (OR logic)
	Or *[]ActionRequirement `json:"or"`
}

// ResponseEvaluateSchema Evaluate response
type ResponseEvaluateSchema struct {
	Input map[string]interface{} `json:"input"`

	// MissingRequired Will be true when a required value is missing
	MissingRequired bool                   `json:"missingRequired"`
	Output          map[string]interface{} `json:"output"`

	// Path path node
	Path PathNode `json:"path"`

	// RequirementsMet Will be true when all requirements where met
	RequirementsMet bool `json:"requirementsMet"`

	// RulespecId Identifier of the rulespec
	RulespecId openapi_types.UUID `json:"rulespecId"`
}

// RuleSpec defines model for RuleSpec.
type RuleSpec struct {
	// Actions Actions associated with the rule
	Actions *[]Action `json:"actions,omitempty"`

	// DecisionType Type of decision
	DecisionType *string `json:"decision_type"`

	// Description Description of the rule specification
	Description string `json:"description"`

	// Discoverable Discoverability setting
	Discoverable *string `json:"discoverable"`

	// Law Associated law reference
	Law string `json:"law"`

	// LawType Type of law
	LawType *string `json:"law_type"`

	// LegalCharacter Legal character of the rule
	LegalCharacter *string `json:"legal_character"`

	// Name Name of the rule specification
	Name       string     `json:"name"`
	Properties Properties `json:"properties"`

	// References Legal references
	References *[]Reference `json:"references,omitempty"`

	// Requirements Requirements for the rule
	Requirements *[]Requirement `json:"requirements,omitempty"`

	// Service Associated service identifier
	Service string `json:"service"`

	// Uuid Unique identifier for the rule specification
	Uuid openapi_types.UUID `json:"uuid"`

	// ValidFrom Date from which the rule is valid
	ValidFrom time.Time `json:"valid_from"`
}

// SelectField defines model for SelectField.
type SelectField struct {
	// Description Field description
	Description string `json:"description"`

	// Name Field name
	Name string `json:"name"`

	// Type Field type
	Type string `json:"type"`

	// Value Represents a value in an operation (can be a primitive value or nested action)
	Value ActionValue `json:"value"`
}

// Service Service
type Service struct {
	Laws []Law `json:"laws"`

	// Name Service name
	Name string `json:"name"`
}

// ServiceList List of all services
type ServiceList = []Service

// ServiceReference defines model for ServiceReference.
type ServiceReference struct {
	// Field Field in the referenced service
	Field string `json:"field"`

	// Law Associated law
	Law string `json:"law"`

	// Parameters Service parameters
	Parameters *[]Parameter `json:"parameters,omitempty"`

	// Service Referenced service identifier
	Service string `json:"service"`
}

// Source A source
type Source map[string][]map[string]interface{}

// SourceField defines model for SourceField.
type SourceField struct {
	// Description Field description
	Description string `json:"description"`

	// Name Field name
	Name string `json:"name"`

	// Required Whether the field is required
	Required         *bool             `json:"required"`
	ServiceReference *ServiceReference `json:"service_reference,omitempty"`
	SourceReference  *SourceReference  `json:"source_reference,omitempty"`
	Temporal         *Temporal         `json:"temporal,omitempty"`

	// Type Field type
	Type     string    `json:"type"`
	TypeSpec *TypeSpec `json:"type_spec,omitempty"`
}

// SourceReference defines model for SourceReference.
type SourceReference struct {
	// Field Specific field to reference
	Field *string `json:"field"`

	// Fields Multiple fields to reference
	Fields *[]string `json:"fields"`

	// SelectOn Selection criteria
	SelectOn *[]SelectField `json:"select_on,omitempty"`

	// SourceType Type of the data source
	SourceType *string `json:"source_type,omitempty"`

	// Table Table name in the source
	Table *string `json:"table,omitempty"`
}

// Temporal defines model for Temporal.
type Temporal struct {
	// ImmutableAfter Immutability rule
	ImmutableAfter *string `json:"immutable_after"`

	// PeriodType Period type specification
	PeriodType *string `json:"period_type"`

	// Reference Reference (can be string or VariableReference)
	Reference *string `json:"reference"`

	// Type Temporal type
	Type string `json:"type"`
}

// TypeSpec defines model for TypeSpec.
type TypeSpec struct {
	// Max Maximum value
	Max *float64 `json:"max"`

	// Min Minimum value
	Min *float64 `json:"min"`

	// Precision Precision for numeric types
	Precision *int `json:"precision"`

	// Type Specific type definition
	Type string `json:"type"`

	// Unit Unit of measurement
	Unit *string `json:"unit"`
}

// Update defines model for Update.
type Update struct {
	// Mapping Field mapping configuration
	Mapping map[string]string `json:"mapping"`

	// Method Update method
	Method string `json:"method"`
}

// Bsn Burgerservicenummer of a Dutch citizen
type Bsn = string

// CaseID Identifier of a case
type CaseID = openapi_types.UUID

// ClaimID Identifier of a claim
type ClaimID = openapi_types.UUID

// DiscoverableBy DiscoverableBy is a string that can be used to filter lists
type DiscoverableBy = string

// ReferenceDate reference date
type ReferenceDate = openapi_types.Date

// PathBSN Burgerservicenummer of a Dutch citizen
type PathBSN = Bsn

// PathCaseID Identifier of a case
type PathCaseID = CaseID

// PathClaimID Identifier of a claim
type PathClaimID = ClaimID

// PathLaw defines model for pathLaw.
type PathLaw = string

// PathService defines model for pathService.
type PathService = string

// QueryDiscoverableBy DiscoverableBy is a string that can be used to filter lists
type QueryDiscoverableBy = DiscoverableBy

// QueryIncludeRejected defines model for queryIncludeRejected.
type QueryIncludeRejected = bool

// QueryLaw defines model for queryLaw.
type QueryLaw = string

// QueryOnlyApproved defines model for queryOnlyApproved.
type QueryOnlyApproved = bool

// QueryReferenceDate reference date
type QueryReferenceDate = ReferenceDate

// QueryService defines model for queryService.
type QueryService = string

// BadRequestErrorResponse defines model for BadRequestErrorResponse.
type BadRequestErrorResponse struct {
	Errors []Error `json:"errors"`
}

// ClaimListResponse defines model for ClaimListResponse.
type ClaimListResponse struct {
	// Data List of all claims
	Data ClaimList `json:"data"`
}

// ClaimListWithKeyResponse defines model for ClaimListWithKeyResponse.
type ClaimListWithKeyResponse struct {
	Data map[string]Claim `json:"data"`
}

// InternalServerErrorResponse defines model for InternalServerErrorResponse.
type InternalServerErrorResponse struct {
	Errors []Error `json:"errors"`
}

// ProfileResponse defines model for ProfileResponse.
type ProfileResponse struct {
	// Data Profile
	Data Profile `json:"data"`
}

// ResourceNotFoundErrorResponse defines model for ResourceNotFoundErrorResponse.
type ResourceNotFoundErrorResponse struct {
	Errors *[]Error `json:"errors,omitempty"`
}

// ResponseCase defines model for ResponseCase.
type ResponseCase struct {
	// Data Case
	Data Case `json:"data"`
}

// ResponseCaseList defines model for ResponseCaseList.
type ResponseCaseList struct {
	// Data List of all cases
	Data CaseList `json:"data"`
}

// ResponseCaseObject defines model for ResponseCaseObject.
type ResponseCaseObject struct {
	// Data Identifier of a case
	Data CaseID `json:"data"`
}

// ResponseCaseReview defines model for ResponseCaseReview.
type ResponseCaseReview struct {
	// Data Identifier of a case
	Data CaseID `json:"data"`
}

// ResponseCaseSubmit defines model for ResponseCaseSubmit.
type ResponseCaseSubmit struct {
	// Data Identifier of a case
	Data CaseID `json:"data"`
}

// ResponseClaimApprove defines model for ResponseClaimApprove.
type ResponseClaimApprove struct {
	// Data Identifier of a claim
	Data ClaimID `json:"data"`
}

// ResponseClaimReject defines model for ResponseClaimReject.
type ResponseClaimReject struct {
	// Data Identifier of a claim
	Data ClaimID `json:"data"`
}

// ResponseClaimSubmit defines model for ResponseClaimSubmit.
type ResponseClaimSubmit struct {
	// Data Identifier of a claim
	Data ClaimID `json:"data"`
}

// ResponseEvaluate defines model for ResponseEvaluate.
type ResponseEvaluate struct {
	// Data Evaluate response
	Data ResponseEvaluateSchema `json:"data"`
}

// ResponseEventList defines model for ResponseEventList.
type ResponseEventList struct {
	// Data List of all events
	Data EventList `json:"data"`
}

// ResponseProfileList defines model for ResponseProfileList.
type ResponseProfileList struct {
	// Data List of all burgers
	Data ProfileList `json:"data"`
}

// RuleSpecResponse defines model for RuleSpecResponse.
type RuleSpecResponse struct {
	Data RuleSpec `json:"data"`
}

// ServiceListResponse defines model for ServiceListResponse.
type ServiceListResponse struct {
	// Data List of all services
	Data ServiceList `json:"data"`
}

// CaseObjectRequest defines model for CaseObjectRequest.
type CaseObjectRequest struct {
	Data CaseObject `json:"data"`
}

// CaseReviewRequest defines model for CaseReviewRequest.
type CaseReviewRequest struct {
	Data CaseReview `json:"data"`
}

// CaseSubmitRequest defines model for CaseSubmitRequest.
type CaseSubmitRequest struct {
	// Data Case
	Data CaseSubmit `json:"data"`
}

// ClaimApproveRequest defines model for ClaimApproveRequest.
type ClaimApproveRequest struct {
	// Data Approve a claim
	Data ClaimApprove `json:"data"`
}

// ClaimRejectRequest defines model for ClaimRejectRequest.
type ClaimRejectRequest struct {
	// Data Reject a claim
	Data ClaimReject `json:"data"`
}

// ClaimSubmitRequest defines model for ClaimSubmitRequest.
type ClaimSubmitRequest struct {
	// Data Submit a new claim
	Data ClaimSubmit `json:"data"`
}

// DataFrameRequest defines model for DataFrameRequest.
type DataFrameRequest struct {
	Data DataFrame `json:"data"`
}

// EvaluateRequest defines model for EvaluateRequest.
type EvaluateRequest struct {
	// Data Evaluate.
	Data Evaluate `json:"data"`
}

// CaseSubmitJSONBody defines parameters for CaseSubmit.
type CaseSubmitJSONBody struct {
	// Data Case
	Data CaseSubmit `json:"data"`
}

// CaseObjectJSONBody defines parameters for CaseObject.
type CaseObjectJSONBody struct {
	Data CaseObject `json:"data"`
}

// CaseReviewJSONBody defines parameters for CaseReview.
type CaseReviewJSONBody struct {
	Data CaseReview `json:"data"`
}

// ClaimSubmitJSONBody defines parameters for ClaimSubmit.
type ClaimSubmitJSONBody struct {
	// Data Submit a new claim
	Data ClaimSubmit `json:"data"`
}

// ClaimListBasedOnBSNParams defines parameters for ClaimListBasedOnBSN.
type ClaimListBasedOnBSNParams struct {
	// Approved If added to URI only approved claims will be returned.
	Approved *QueryOnlyApproved `form:"approved,omitempty" json:"approved,omitempty"`

	// IncludeRejected If added to URI rejected claims will be added to the return
	IncludeRejected *QueryIncludeRejected `form:"includeRejected,omitempty" json:"includeRejected,omitempty"`
}

// ClaimListBasedOnBSNServiceLawParams defines parameters for ClaimListBasedOnBSNServiceLaw.
type ClaimListBasedOnBSNServiceLawParams struct {
	// Approved If added to URI only approved claims will be returned.
	Approved *QueryOnlyApproved `form:"approved,omitempty" json:"approved,omitempty"`

	// IncludeRejected If added to URI rejected claims will be added to the return
	IncludeRejected *QueryIncludeRejected `form:"includeRejected,omitempty" json:"includeRejected,omitempty"`
}

// ClaimApproveJSONBody defines parameters for ClaimApprove.
type ClaimApproveJSONBody struct {
	// Data Approve a claim
	Data ClaimApprove `json:"data"`
}

// ClaimRejectJSONBody defines parameters for ClaimReject.
type ClaimRejectJSONBody struct {
	// Data Reject a claim
	Data ClaimReject `json:"data"`
}

// ServiceLawsDiscoverableListParams defines parameters for ServiceLawsDiscoverableList.
type ServiceLawsDiscoverableListParams struct {
	// DiscoverableBy Filter for discoverable by, defaults to 'CITIZEN'
	DiscoverableBy *QueryDiscoverableBy `form:"discoverableBy,omitempty" json:"discoverableBy,omitempty"`
}

// EvaluateJSONBody defines parameters for Evaluate.
type EvaluateJSONBody struct {
	// Data Evaluate.
	Data Evaluate `json:"data"`
}

// RuleSpecGetParams defines parameters for RuleSpecGet.
type RuleSpecGetParams struct {
	// Service filter for service
	Service QueryService `form:"service" json:"service"`

	// Law filter for law
	Law QueryLaw `form:"law" json:"law"`

	// ReferenceDate reference date
	ReferenceDate QueryReferenceDate `form:"referenceDate" json:"referenceDate"`
}

// SetSourceDataFrameJSONBody defines parameters for SetSourceDataFrame.
type SetSourceDataFrameJSONBody struct {
	Data DataFrame `json:"data"`
}

// CaseSubmitJSONRequestBody defines body for CaseSubmit for application/json ContentType.
type CaseSubmitJSONRequestBody CaseSubmitJSONBody

// CaseObjectJSONRequestBody defines body for CaseObject for application/json ContentType.
type CaseObjectJSONRequestBody CaseObjectJSONBody

// CaseReviewJSONRequestBody defines body for CaseReview for application/json ContentType.
type CaseReviewJSONRequestBody CaseReviewJSONBody

// ClaimSubmitJSONRequestBody defines body for ClaimSubmit for application/json ContentType.
type ClaimSubmitJSONRequestBody ClaimSubmitJSONBody

// ClaimApproveJSONRequestBody defines body for ClaimApprove for application/json ContentType.
type ClaimApproveJSONRequestBody ClaimApproveJSONBody

// ClaimRejectJSONRequestBody defines body for ClaimReject for application/json ContentType.
type ClaimRejectJSONRequestBody ClaimRejectJSONBody

// EvaluateJSONRequestBody defines body for Evaluate for application/json ContentType.
type EvaluateJSONRequestBody EvaluateJSONBody

// SetSourceDataFrameJSONRequestBody defines body for SetSourceDataFrame for application/json ContentType.
type SetSourceDataFrameJSONRequestBody SetSourceDataFrameJSONBody

// AsRequirement returns the union data inside the ActionRequirement as a Requirement
func (t ActionRequirement) AsRequirement() (Requirement, error) {
	var body Requirement
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequirement overwrites any union data inside the ActionRequirement as the provided Requirement
func (t *ActionRequirement) FromRequirement(v Requirement) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequirement performs a merge with any union data inside the ActionRequirement, using the provided Requirement
func (t *ActionRequirement) MergeRequirement(v Requirement) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAction returns the union data inside the ActionRequirement as a Action
func (t ActionRequirement) AsAction() (Action, error) {
	var body Action
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAction overwrites any union data inside the ActionRequirement as the provided Action
func (t *ActionRequirement) FromAction(v Action) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAction performs a merge with any union data inside the ActionRequirement, using the provided Action
func (t *ActionRequirement) MergeAction(v Action) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionRequirement) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionRequirement) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAction returns the union data inside the ActionValue as a Action
func (t ActionValue) AsAction() (Action, error) {
	var body Action
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAction overwrites any union data inside the ActionValue as the provided Action
func (t *ActionValue) FromAction(v Action) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAction performs a merge with any union data inside the ActionValue, using the provided Action
func (t *ActionValue) MergeAction(v Action) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionValue1 returns the union data inside the ActionValue as a ActionValue1
func (t ActionValue) AsActionValue1() (ActionValue1, error) {
	var body ActionValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionValue1 overwrites any union data inside the ActionValue as the provided ActionValue1
func (t *ActionValue) FromActionValue1(v ActionValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionValue1 performs a merge with any union data inside the ActionValue, using the provided ActionValue1
func (t *ActionValue) MergeActionValue1(v ActionValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsActionValues0 returns the union data inside the ActionValues as a ActionValues0
func (t ActionValues) AsActionValues0() (ActionValues0, error) {
	var body ActionValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionValues0 overwrites any union data inside the ActionValues as the provided ActionValues0
func (t *ActionValues) FromActionValues0(v ActionValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionValues0 performs a merge with any union data inside the ActionValues, using the provided ActionValues0
func (t *ActionValues) MergeActionValues0(v ActionValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionValues1 returns the union data inside the ActionValues as a ActionValues1
func (t ActionValues) AsActionValues1() (ActionValues1, error) {
	var body ActionValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionValues1 overwrites any union data inside the ActionValues as the provided ActionValues1
func (t *ActionValues) FromActionValues1(v ActionValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionValues1 performs a merge with any union data inside the ActionValues, using the provided ActionValues1
func (t *ActionValues) MergeActionValues1(v ActionValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionValues) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionValues) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CaseSubmitWithBody request with any body
	CaseSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CaseSubmit(ctx context.Context, body CaseSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseGet request
	CaseGet(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventListBasedOnCaseID request
	EventListBasedOnCaseID(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseListBasedOnBSN request
	CaseListBasedOnBSN(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseBasedOnBSNServiceLaw request
	CaseBasedOnBSNServiceLaw(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseObjectWithBody request with any body
	CaseObjectWithBody(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CaseObject(ctx context.Context, caseID PathCaseID, body CaseObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseReviewWithBody request with any body
	CaseReviewWithBody(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CaseReview(ctx context.Context, caseID PathCaseID, body CaseReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CaseListBasedOnServiceLaw request
	CaseListBasedOnServiceLaw(ctx context.Context, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimSubmitWithBody request with any body
	ClaimSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClaimSubmit(ctx context.Context, body ClaimSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimListBasedOnBSN request
	ClaimListBasedOnBSN(ctx context.Context, bsn PathBSN, params *ClaimListBasedOnBSNParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimListBasedOnBSNServiceLaw request
	ClaimListBasedOnBSNServiceLaw(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, params *ClaimListBasedOnBSNServiceLawParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimApproveWithBody request with any body
	ClaimApproveWithBody(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClaimApprove(ctx context.Context, claimId PathClaimID, body ClaimApproveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimRejectWithBody request with any body
	ClaimRejectWithBody(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ClaimReject(ctx context.Context, claimId PathClaimID, body ClaimRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ServiceLawsDiscoverableList request
	ServiceLawsDiscoverableList(ctx context.Context, params *ServiceLawsDiscoverableListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetEngine request
	ResetEngine(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EvaluateWithBody request with any body
	EvaluateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Evaluate(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EventList request
	EventList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileList request
	ProfileList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ProfileGet request
	ProfileGet(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RuleSpecGet request
	RuleSpecGet(ctx context.Context, params *RuleSpecGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetSourceDataFrameWithBody request with any body
	SetSourceDataFrameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetSourceDataFrame(ctx context.Context, body SetSourceDataFrameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CaseSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseSubmit(ctx context.Context, body CaseSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseGet(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseGetRequest(c.Server, caseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventListBasedOnCaseID(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventListBasedOnCaseIDRequest(c.Server, caseID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseListBasedOnBSN(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseListBasedOnBSNRequest(c.Server, bsn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseBasedOnBSNServiceLaw(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseBasedOnBSNServiceLawRequest(c.Server, bsn, service, law)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseObjectWithBody(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseObjectRequestWithBody(c.Server, caseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseObject(ctx context.Context, caseID PathCaseID, body CaseObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseObjectRequest(c.Server, caseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseReviewWithBody(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseReviewRequestWithBody(c.Server, caseID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseReview(ctx context.Context, caseID PathCaseID, body CaseReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseReviewRequest(c.Server, caseID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CaseListBasedOnServiceLaw(ctx context.Context, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCaseListBasedOnServiceLawRequest(c.Server, service, law)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimSubmit(ctx context.Context, body ClaimSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimListBasedOnBSN(ctx context.Context, bsn PathBSN, params *ClaimListBasedOnBSNParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimListBasedOnBSNRequest(c.Server, bsn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimListBasedOnBSNServiceLaw(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, params *ClaimListBasedOnBSNServiceLawParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimListBasedOnBSNServiceLawRequest(c.Server, bsn, service, law, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimApproveWithBody(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimApproveRequestWithBody(c.Server, claimId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimApprove(ctx context.Context, claimId PathClaimID, body ClaimApproveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimApproveRequest(c.Server, claimId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimRejectWithBody(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimRejectRequestWithBody(c.Server, claimId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimReject(ctx context.Context, claimId PathClaimID, body ClaimRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimRejectRequest(c.Server, claimId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ServiceLawsDiscoverableList(ctx context.Context, params *ServiceLawsDiscoverableListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServiceLawsDiscoverableListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetEngine(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetEngineRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EvaluateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Evaluate(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEvaluateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EventList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEventListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ProfileGet(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewProfileGetRequest(c.Server, bsn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RuleSpecGet(ctx context.Context, params *RuleSpecGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRuleSpecGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSourceDataFrameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSourceDataFrameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetSourceDataFrame(ctx context.Context, body SetSourceDataFrameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetSourceDataFrameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCaseSubmitRequest calls the generic CaseSubmit builder with application/json body
func NewCaseSubmitRequest(server string, body CaseSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCaseSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewCaseSubmitRequestWithBody generates requests for CaseSubmit with any type of body
func NewCaseSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/case")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCaseGetRequest generates requests for CaseGet
func NewCaseGetRequest(server string, caseID PathCaseID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "caseID", runtime.ParamLocationPath, caseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/case/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEventListBasedOnCaseIDRequest generates requests for EventListBasedOnCaseID
func NewEventListBasedOnCaseIDRequest(server string, caseID PathCaseID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "caseID", runtime.ParamLocationPath, caseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/case/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCaseListBasedOnBSNRequest generates requests for CaseListBasedOnBSN
func NewCaseListBasedOnBSNRequest(server string, bsn PathBSN) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bsn", runtime.ParamLocationPath, bsn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cases/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCaseBasedOnBSNServiceLawRequest generates requests for CaseBasedOnBSNServiceLaw
func NewCaseBasedOnBSNServiceLawRequest(server string, bsn PathBSN, service PathService, law PathLaw) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bsn", runtime.ParamLocationPath, bsn)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service", runtime.ParamLocationPath, service)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "law", runtime.ParamLocationPath, law)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cases/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCaseObjectRequest calls the generic CaseObject builder with application/json body
func NewCaseObjectRequest(server string, caseID PathCaseID, body CaseObjectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCaseObjectRequestWithBody(server, caseID, "application/json", bodyReader)
}

// NewCaseObjectRequestWithBody generates requests for CaseObject with any type of body
func NewCaseObjectRequestWithBody(server string, caseID PathCaseID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "caseID", runtime.ParamLocationPath, caseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cases/%s/object", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCaseReviewRequest calls the generic CaseReview builder with application/json body
func NewCaseReviewRequest(server string, caseID PathCaseID, body CaseReviewJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCaseReviewRequestWithBody(server, caseID, "application/json", bodyReader)
}

// NewCaseReviewRequestWithBody generates requests for CaseReview with any type of body
func NewCaseReviewRequestWithBody(server string, caseID PathCaseID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "caseID", runtime.ParamLocationPath, caseID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cases/%s/review", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCaseListBasedOnServiceLawRequest generates requests for CaseListBasedOnServiceLaw
func NewCaseListBasedOnServiceLawRequest(server string, service PathService, law PathLaw) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "service", runtime.ParamLocationPath, service)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "law", runtime.ParamLocationPath, law)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cases/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClaimSubmitRequest calls the generic ClaimSubmit builder with application/json body
func NewClaimSubmitRequest(server string, body ClaimSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClaimSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewClaimSubmitRequestWithBody generates requests for ClaimSubmit with any type of body
func NewClaimSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClaimListBasedOnBSNRequest generates requests for ClaimListBasedOnBSN
func NewClaimListBasedOnBSNRequest(server string, bsn PathBSN, params *ClaimListBasedOnBSNParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bsn", runtime.ParamLocationPath, bsn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approved", runtime.ParamLocationQuery, *params.Approved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeRejected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeRejected", runtime.ParamLocationQuery, *params.IncludeRejected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClaimListBasedOnBSNServiceLawRequest generates requests for ClaimListBasedOnBSNServiceLaw
func NewClaimListBasedOnBSNServiceLawRequest(server string, bsn PathBSN, service PathService, law PathLaw, params *ClaimListBasedOnBSNServiceLawParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bsn", runtime.ParamLocationPath, bsn)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "service", runtime.ParamLocationPath, service)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "law", runtime.ParamLocationPath, law)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Approved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "approved", runtime.ParamLocationQuery, *params.Approved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeRejected != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeRejected", runtime.ParamLocationQuery, *params.IncludeRejected); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClaimApproveRequest calls the generic ClaimApprove builder with application/json body
func NewClaimApproveRequest(server string, claimId PathClaimID, body ClaimApproveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClaimApproveRequestWithBody(server, claimId, "application/json", bodyReader)
}

// NewClaimApproveRequestWithBody generates requests for ClaimApprove with any type of body
func NewClaimApproveRequestWithBody(server string, claimId PathClaimID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "claimId", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s/approve", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClaimRejectRequest calls the generic ClaimReject builder with application/json body
func NewClaimRejectRequest(server string, claimId PathClaimID, body ClaimRejectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewClaimRejectRequestWithBody(server, claimId, "application/json", bodyReader)
}

// NewClaimRejectRequestWithBody generates requests for ClaimReject with any type of body
func NewClaimRejectRequestWithBody(server string, claimId PathClaimID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "claimId", runtime.ParamLocationPath, claimId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s/reject", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewServiceLawsDiscoverableListRequest generates requests for ServiceLawsDiscoverableList
func NewServiceLawsDiscoverableListRequest(server string, params *ServiceLawsDiscoverableListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/discoverable-service-laws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DiscoverableBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "discoverableBy", runtime.ParamLocationQuery, *params.DiscoverableBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResetEngineRequest generates requests for ResetEngine
func NewResetEngineRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/engine/reset")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEvaluateRequest calls the generic Evaluate builder with application/json body
func NewEvaluateRequest(server string, body EvaluateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEvaluateRequestWithBody(server, "application/json", bodyReader)
}

// NewEvaluateRequestWithBody generates requests for Evaluate with any type of body
func NewEvaluateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/evaluate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEventListRequest generates requests for EventList
func NewEventListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileListRequest generates requests for ProfileList
func NewProfileListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewProfileGetRequest generates requests for ProfileGet
func NewProfileGetRequest(server string, bsn PathBSN) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bsn", runtime.ParamLocationPath, bsn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/profiles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRuleSpecGetRequest generates requests for RuleSpecGet
func NewRuleSpecGetRequest(server string, params *RuleSpecGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rule-spec")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "service", runtime.ParamLocationQuery, params.Service); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "law", runtime.ParamLocationQuery, params.Law); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "referenceDate", runtime.ParamLocationQuery, params.ReferenceDate); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetSourceDataFrameRequest calls the generic SetSourceDataFrame builder with application/json body
func NewSetSourceDataFrameRequest(server string, body SetSourceDataFrameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetSourceDataFrameRequestWithBody(server, "application/json", bodyReader)
}

// NewSetSourceDataFrameRequestWithBody generates requests for SetSourceDataFrame with any type of body
func NewSetSourceDataFrameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/source-dataframe")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CaseSubmitWithBodyWithResponse request with any body
	CaseSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseSubmitResponse, error)

	CaseSubmitWithResponse(ctx context.Context, body CaseSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseSubmitResponse, error)

	// CaseGetWithResponse request
	CaseGetWithResponse(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*CaseGetResponse, error)

	// EventListBasedOnCaseIDWithResponse request
	EventListBasedOnCaseIDWithResponse(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*EventListBasedOnCaseIDResponse, error)

	// CaseListBasedOnBSNWithResponse request
	CaseListBasedOnBSNWithResponse(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*CaseListBasedOnBSNResponse, error)

	// CaseBasedOnBSNServiceLawWithResponse request
	CaseBasedOnBSNServiceLawWithResponse(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*CaseBasedOnBSNServiceLawResponse, error)

	// CaseObjectWithBodyWithResponse request with any body
	CaseObjectWithBodyWithResponse(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseObjectResponse, error)

	CaseObjectWithResponse(ctx context.Context, caseID PathCaseID, body CaseObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseObjectResponse, error)

	// CaseReviewWithBodyWithResponse request with any body
	CaseReviewWithBodyWithResponse(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseReviewResponse, error)

	CaseReviewWithResponse(ctx context.Context, caseID PathCaseID, body CaseReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseReviewResponse, error)

	// CaseListBasedOnServiceLawWithResponse request
	CaseListBasedOnServiceLawWithResponse(ctx context.Context, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*CaseListBasedOnServiceLawResponse, error)

	// ClaimSubmitWithBodyWithResponse request with any body
	ClaimSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimSubmitResponse, error)

	ClaimSubmitWithResponse(ctx context.Context, body ClaimSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimSubmitResponse, error)

	// ClaimListBasedOnBSNWithResponse request
	ClaimListBasedOnBSNWithResponse(ctx context.Context, bsn PathBSN, params *ClaimListBasedOnBSNParams, reqEditors ...RequestEditorFn) (*ClaimListBasedOnBSNResponse, error)

	// ClaimListBasedOnBSNServiceLawWithResponse request
	ClaimListBasedOnBSNServiceLawWithResponse(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, params *ClaimListBasedOnBSNServiceLawParams, reqEditors ...RequestEditorFn) (*ClaimListBasedOnBSNServiceLawResponse, error)

	// ClaimApproveWithBodyWithResponse request with any body
	ClaimApproveWithBodyWithResponse(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimApproveResponse, error)

	ClaimApproveWithResponse(ctx context.Context, claimId PathClaimID, body ClaimApproveJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimApproveResponse, error)

	// ClaimRejectWithBodyWithResponse request with any body
	ClaimRejectWithBodyWithResponse(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimRejectResponse, error)

	ClaimRejectWithResponse(ctx context.Context, claimId PathClaimID, body ClaimRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimRejectResponse, error)

	// ServiceLawsDiscoverableListWithResponse request
	ServiceLawsDiscoverableListWithResponse(ctx context.Context, params *ServiceLawsDiscoverableListParams, reqEditors ...RequestEditorFn) (*ServiceLawsDiscoverableListResponse, error)

	// ResetEngineWithResponse request
	ResetEngineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetEngineResponse, error)

	// EvaluateWithBodyWithResponse request with any body
	EvaluateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateResponse, error)

	EvaluateWithResponse(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateResponse, error)

	// EventListWithResponse request
	EventListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EventListResponse, error)

	// ProfileListWithResponse request
	ProfileListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileListResponse, error)

	// ProfileGetWithResponse request
	ProfileGetWithResponse(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*ProfileGetResponse, error)

	// RuleSpecGetWithResponse request
	RuleSpecGetWithResponse(ctx context.Context, params *RuleSpecGetParams, reqEditors ...RequestEditorFn) (*RuleSpecGetResponse, error)

	// SetSourceDataFrameWithBodyWithResponse request with any body
	SetSourceDataFrameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSourceDataFrameResponse, error)

	SetSourceDataFrameWithResponse(ctx context.Context, body SetSourceDataFrameJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSourceDataFrameResponse, error)
}

type CaseSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ResponseCaseSubmit
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCase
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventListBasedOnCaseIDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseEventList
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r EventListBasedOnCaseIDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventListBasedOnCaseIDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseListBasedOnBSNResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCaseList
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseListBasedOnBSNResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseListBasedOnBSNResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseBasedOnBSNServiceLawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCase
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseBasedOnBSNServiceLawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseBasedOnBSNServiceLawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseObjectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCaseObject
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseObjectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseObjectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseReviewResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCaseReview
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseReviewResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseReviewResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CaseListBasedOnServiceLawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseCaseList
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r CaseListBasedOnServiceLawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CaseListBasedOnServiceLawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ResponseClaimSubmit
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClaimSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimListBasedOnBSNResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClaimListResponse
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClaimListBasedOnBSNResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimListBasedOnBSNResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimListBasedOnBSNServiceLawResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClaimListWithKeyResponse
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClaimListBasedOnBSNServiceLawResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimListBasedOnBSNServiceLawResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimApproveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseClaimApprove
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClaimApproveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimApproveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimRejectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseClaimReject
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ClaimRejectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimRejectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServiceLawsDiscoverableListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceListResponse
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ServiceLawsDiscoverableListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServiceLawsDiscoverableListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetEngineResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ResetEngineResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetEngineResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EvaluateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ResponseEvaluate
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r EvaluateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EvaluateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EventListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseEventList
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r EventListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EventListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseProfileList
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfileListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ProfileGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProfileResponse
	JSON400      *BadRequestErrorResponse
	JSON404      *ResourceNotFoundErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r ProfileGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProfileGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RuleSpecGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuleSpecResponse
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r RuleSpecGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RuleSpecGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetSourceDataFrameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequestErrorResponse
	JSON500      *InternalServerErrorResponse
}

// Status returns HTTPResponse.Status
func (r SetSourceDataFrameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetSourceDataFrameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CaseSubmitWithBodyWithResponse request with arbitrary body returning *CaseSubmitResponse
func (c *ClientWithResponses) CaseSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseSubmitResponse, error) {
	rsp, err := c.CaseSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseSubmitResponse(rsp)
}

func (c *ClientWithResponses) CaseSubmitWithResponse(ctx context.Context, body CaseSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseSubmitResponse, error) {
	rsp, err := c.CaseSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseSubmitResponse(rsp)
}

// CaseGetWithResponse request returning *CaseGetResponse
func (c *ClientWithResponses) CaseGetWithResponse(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*CaseGetResponse, error) {
	rsp, err := c.CaseGet(ctx, caseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseGetResponse(rsp)
}

// EventListBasedOnCaseIDWithResponse request returning *EventListBasedOnCaseIDResponse
func (c *ClientWithResponses) EventListBasedOnCaseIDWithResponse(ctx context.Context, caseID PathCaseID, reqEditors ...RequestEditorFn) (*EventListBasedOnCaseIDResponse, error) {
	rsp, err := c.EventListBasedOnCaseID(ctx, caseID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventListBasedOnCaseIDResponse(rsp)
}

// CaseListBasedOnBSNWithResponse request returning *CaseListBasedOnBSNResponse
func (c *ClientWithResponses) CaseListBasedOnBSNWithResponse(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*CaseListBasedOnBSNResponse, error) {
	rsp, err := c.CaseListBasedOnBSN(ctx, bsn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseListBasedOnBSNResponse(rsp)
}

// CaseBasedOnBSNServiceLawWithResponse request returning *CaseBasedOnBSNServiceLawResponse
func (c *ClientWithResponses) CaseBasedOnBSNServiceLawWithResponse(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*CaseBasedOnBSNServiceLawResponse, error) {
	rsp, err := c.CaseBasedOnBSNServiceLaw(ctx, bsn, service, law, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseBasedOnBSNServiceLawResponse(rsp)
}

// CaseObjectWithBodyWithResponse request with arbitrary body returning *CaseObjectResponse
func (c *ClientWithResponses) CaseObjectWithBodyWithResponse(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseObjectResponse, error) {
	rsp, err := c.CaseObjectWithBody(ctx, caseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseObjectResponse(rsp)
}

func (c *ClientWithResponses) CaseObjectWithResponse(ctx context.Context, caseID PathCaseID, body CaseObjectJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseObjectResponse, error) {
	rsp, err := c.CaseObject(ctx, caseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseObjectResponse(rsp)
}

// CaseReviewWithBodyWithResponse request with arbitrary body returning *CaseReviewResponse
func (c *ClientWithResponses) CaseReviewWithBodyWithResponse(ctx context.Context, caseID PathCaseID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CaseReviewResponse, error) {
	rsp, err := c.CaseReviewWithBody(ctx, caseID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseReviewResponse(rsp)
}

func (c *ClientWithResponses) CaseReviewWithResponse(ctx context.Context, caseID PathCaseID, body CaseReviewJSONRequestBody, reqEditors ...RequestEditorFn) (*CaseReviewResponse, error) {
	rsp, err := c.CaseReview(ctx, caseID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseReviewResponse(rsp)
}

// CaseListBasedOnServiceLawWithResponse request returning *CaseListBasedOnServiceLawResponse
func (c *ClientWithResponses) CaseListBasedOnServiceLawWithResponse(ctx context.Context, service PathService, law PathLaw, reqEditors ...RequestEditorFn) (*CaseListBasedOnServiceLawResponse, error) {
	rsp, err := c.CaseListBasedOnServiceLaw(ctx, service, law, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCaseListBasedOnServiceLawResponse(rsp)
}

// ClaimSubmitWithBodyWithResponse request with arbitrary body returning *ClaimSubmitResponse
func (c *ClientWithResponses) ClaimSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimSubmitResponse, error) {
	rsp, err := c.ClaimSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimSubmitResponse(rsp)
}

func (c *ClientWithResponses) ClaimSubmitWithResponse(ctx context.Context, body ClaimSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimSubmitResponse, error) {
	rsp, err := c.ClaimSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimSubmitResponse(rsp)
}

// ClaimListBasedOnBSNWithResponse request returning *ClaimListBasedOnBSNResponse
func (c *ClientWithResponses) ClaimListBasedOnBSNWithResponse(ctx context.Context, bsn PathBSN, params *ClaimListBasedOnBSNParams, reqEditors ...RequestEditorFn) (*ClaimListBasedOnBSNResponse, error) {
	rsp, err := c.ClaimListBasedOnBSN(ctx, bsn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimListBasedOnBSNResponse(rsp)
}

// ClaimListBasedOnBSNServiceLawWithResponse request returning *ClaimListBasedOnBSNServiceLawResponse
func (c *ClientWithResponses) ClaimListBasedOnBSNServiceLawWithResponse(ctx context.Context, bsn PathBSN, service PathService, law PathLaw, params *ClaimListBasedOnBSNServiceLawParams, reqEditors ...RequestEditorFn) (*ClaimListBasedOnBSNServiceLawResponse, error) {
	rsp, err := c.ClaimListBasedOnBSNServiceLaw(ctx, bsn, service, law, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimListBasedOnBSNServiceLawResponse(rsp)
}

// ClaimApproveWithBodyWithResponse request with arbitrary body returning *ClaimApproveResponse
func (c *ClientWithResponses) ClaimApproveWithBodyWithResponse(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimApproveResponse, error) {
	rsp, err := c.ClaimApproveWithBody(ctx, claimId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimApproveResponse(rsp)
}

func (c *ClientWithResponses) ClaimApproveWithResponse(ctx context.Context, claimId PathClaimID, body ClaimApproveJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimApproveResponse, error) {
	rsp, err := c.ClaimApprove(ctx, claimId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimApproveResponse(rsp)
}

// ClaimRejectWithBodyWithResponse request with arbitrary body returning *ClaimRejectResponse
func (c *ClientWithResponses) ClaimRejectWithBodyWithResponse(ctx context.Context, claimId PathClaimID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ClaimRejectResponse, error) {
	rsp, err := c.ClaimRejectWithBody(ctx, claimId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimRejectResponse(rsp)
}

func (c *ClientWithResponses) ClaimRejectWithResponse(ctx context.Context, claimId PathClaimID, body ClaimRejectJSONRequestBody, reqEditors ...RequestEditorFn) (*ClaimRejectResponse, error) {
	rsp, err := c.ClaimReject(ctx, claimId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimRejectResponse(rsp)
}

// ServiceLawsDiscoverableListWithResponse request returning *ServiceLawsDiscoverableListResponse
func (c *ClientWithResponses) ServiceLawsDiscoverableListWithResponse(ctx context.Context, params *ServiceLawsDiscoverableListParams, reqEditors ...RequestEditorFn) (*ServiceLawsDiscoverableListResponse, error) {
	rsp, err := c.ServiceLawsDiscoverableList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServiceLawsDiscoverableListResponse(rsp)
}

// ResetEngineWithResponse request returning *ResetEngineResponse
func (c *ClientWithResponses) ResetEngineWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ResetEngineResponse, error) {
	rsp, err := c.ResetEngine(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetEngineResponse(rsp)
}

// EvaluateWithBodyWithResponse request with arbitrary body returning *EvaluateResponse
func (c *ClientWithResponses) EvaluateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EvaluateResponse, error) {
	rsp, err := c.EvaluateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateResponse(rsp)
}

func (c *ClientWithResponses) EvaluateWithResponse(ctx context.Context, body EvaluateJSONRequestBody, reqEditors ...RequestEditorFn) (*EvaluateResponse, error) {
	rsp, err := c.Evaluate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEvaluateResponse(rsp)
}

// EventListWithResponse request returning *EventListResponse
func (c *ClientWithResponses) EventListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*EventListResponse, error) {
	rsp, err := c.EventList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEventListResponse(rsp)
}

// ProfileListWithResponse request returning *ProfileListResponse
func (c *ClientWithResponses) ProfileListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ProfileListResponse, error) {
	rsp, err := c.ProfileList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileListResponse(rsp)
}

// ProfileGetWithResponse request returning *ProfileGetResponse
func (c *ClientWithResponses) ProfileGetWithResponse(ctx context.Context, bsn PathBSN, reqEditors ...RequestEditorFn) (*ProfileGetResponse, error) {
	rsp, err := c.ProfileGet(ctx, bsn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseProfileGetResponse(rsp)
}

// RuleSpecGetWithResponse request returning *RuleSpecGetResponse
func (c *ClientWithResponses) RuleSpecGetWithResponse(ctx context.Context, params *RuleSpecGetParams, reqEditors ...RequestEditorFn) (*RuleSpecGetResponse, error) {
	rsp, err := c.RuleSpecGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRuleSpecGetResponse(rsp)
}

// SetSourceDataFrameWithBodyWithResponse request with arbitrary body returning *SetSourceDataFrameResponse
func (c *ClientWithResponses) SetSourceDataFrameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetSourceDataFrameResponse, error) {
	rsp, err := c.SetSourceDataFrameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSourceDataFrameResponse(rsp)
}

func (c *ClientWithResponses) SetSourceDataFrameWithResponse(ctx context.Context, body SetSourceDataFrameJSONRequestBody, reqEditors ...RequestEditorFn) (*SetSourceDataFrameResponse, error) {
	rsp, err := c.SetSourceDataFrame(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetSourceDataFrameResponse(rsp)
}

// ParseCaseSubmitResponse parses an HTTP response from a CaseSubmitWithResponse call
func ParseCaseSubmitResponse(rsp *http.Response) (*CaseSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ResponseCaseSubmit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseGetResponse parses an HTTP response from a CaseGetWithResponse call
func ParseCaseGetResponse(rsp *http.Response) (*CaseGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEventListBasedOnCaseIDResponse parses an HTTP response from a EventListBasedOnCaseIDWithResponse call
func ParseEventListBasedOnCaseIDResponse(rsp *http.Response) (*EventListBasedOnCaseIDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventListBasedOnCaseIDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseListBasedOnBSNResponse parses an HTTP response from a CaseListBasedOnBSNWithResponse call
func ParseCaseListBasedOnBSNResponse(rsp *http.Response) (*CaseListBasedOnBSNResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseListBasedOnBSNResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCaseList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseBasedOnBSNServiceLawResponse parses an HTTP response from a CaseBasedOnBSNServiceLawWithResponse call
func ParseCaseBasedOnBSNServiceLawResponse(rsp *http.Response) (*CaseBasedOnBSNServiceLawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseBasedOnBSNServiceLawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCase
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseObjectResponse parses an HTTP response from a CaseObjectWithResponse call
func ParseCaseObjectResponse(rsp *http.Response) (*CaseObjectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseObjectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCaseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseReviewResponse parses an HTTP response from a CaseReviewWithResponse call
func ParseCaseReviewResponse(rsp *http.Response) (*CaseReviewResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseReviewResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCaseReview
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCaseListBasedOnServiceLawResponse parses an HTTP response from a CaseListBasedOnServiceLawWithResponse call
func ParseCaseListBasedOnServiceLawResponse(rsp *http.Response) (*CaseListBasedOnServiceLawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CaseListBasedOnServiceLawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseCaseList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimSubmitResponse parses an HTTP response from a ClaimSubmitWithResponse call
func ParseClaimSubmitResponse(rsp *http.Response) (*ClaimSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ResponseClaimSubmit
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimListBasedOnBSNResponse parses an HTTP response from a ClaimListBasedOnBSNWithResponse call
func ParseClaimListBasedOnBSNResponse(rsp *http.Response) (*ClaimListBasedOnBSNResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimListBasedOnBSNResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClaimListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimListBasedOnBSNServiceLawResponse parses an HTTP response from a ClaimListBasedOnBSNServiceLawWithResponse call
func ParseClaimListBasedOnBSNServiceLawResponse(rsp *http.Response) (*ClaimListBasedOnBSNServiceLawResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimListBasedOnBSNServiceLawResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClaimListWithKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimApproveResponse parses an HTTP response from a ClaimApproveWithResponse call
func ParseClaimApproveResponse(rsp *http.Response) (*ClaimApproveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimApproveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseClaimApprove
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimRejectResponse parses an HTTP response from a ClaimRejectWithResponse call
func ParseClaimRejectResponse(rsp *http.Response) (*ClaimRejectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimRejectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseClaimReject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseServiceLawsDiscoverableListResponse parses an HTTP response from a ServiceLawsDiscoverableListWithResponse call
func ParseServiceLawsDiscoverableListResponse(rsp *http.Response) (*ServiceLawsDiscoverableListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServiceLawsDiscoverableListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResetEngineResponse parses an HTTP response from a ResetEngineWithResponse call
func ParseResetEngineResponse(rsp *http.Response) (*ResetEngineResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetEngineResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEvaluateResponse parses an HTTP response from a EvaluateWithResponse call
func ParseEvaluateResponse(rsp *http.Response) (*EvaluateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EvaluateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ResponseEvaluate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEventListResponse parses an HTTP response from a EventListWithResponse call
func ParseEventListResponse(rsp *http.Response) (*EventListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EventListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseEventList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProfileListResponse parses an HTTP response from a ProfileListWithResponse call
func ParseProfileListResponse(rsp *http.Response) (*ProfileListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseProfileList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseProfileGetResponse parses an HTTP response from a ProfileGetWithResponse call
func ParseProfileGetResponse(rsp *http.Response) (*ProfileGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ProfileGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProfileResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ResourceNotFoundErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRuleSpecGetResponse parses an HTTP response from a RuleSpecGetWithResponse call
func ParseRuleSpecGetResponse(rsp *http.Response) (*RuleSpecGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RuleSpecGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuleSpecResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetSourceDataFrameResponse parses an HTTP response from a SetSourceDataFrameWithResponse call
func ParseSetSourceDataFrameResponse(rsp *http.Response) (*SetSourceDataFrameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetSourceDataFrameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
